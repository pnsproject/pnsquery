"""
Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive.
"""
directive @entity on OBJECT

"""Defined a Subgraph ID for an object type"""
directive @subgraphId(id: String!) on OBJECT

"""
creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API.
"""
directive @derivedFrom(field: String!) on FIELD_DEFINITION

type Account {
  id: Bytes!
  domains(skip: Int = 0, first: Int = 100, orderBy: Domain_orderBy, orderDirection: OrderDirection, where: Domain_filter): [Domain!]!
  authorities(skip: Int = 0, first: Int = 100, orderBy: AuthorisationChanged_orderBy, orderDirection: OrderDirection, where: AuthorisationChanged_filter): [AuthorisationChanged!]
  authoriseds(skip: Int = 0, first: Int = 100, orderBy: AuthorisationChanged_orderBy, orderDirection: OrderDirection, where: AuthorisationChanged_filter): [AuthorisationChanged!]
  registrations(skip: Int = 0, first: Int = 100, orderBy: RegistrationEvent_orderBy, orderDirection: OrderDirection, where: RegistrationEvent_filter): [RegistrationEvent!]
  events(skip: Int = 0, first: Int = 100, orderBy: AccountEvent_orderBy, orderDirection: OrderDirection, where: AccountEvent_filter): [AccountEvent!]
}

interface AccountEvent {
  id: ID!
  account: Account!
  blockNumber: Int!
  triggeredDate: BigInt!
  transactionID: Bytes!
}

input AccountEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  account: String
  account_not: String
  account_gt: String
  account_lt: String
  account_gte: String
  account_lte: String
  account_in: [String!]
  account_not_in: [String!]
  account_contains: String
  account_contains_nocase: String
  account_not_contains: String
  account_not_contains_nocase: String
  account_starts_with: String
  account_starts_with_nocase: String
  account_not_starts_with: String
  account_not_starts_with_nocase: String
  account_ends_with: String
  account_ends_with_nocase: String
  account_not_ends_with: String
  account_not_ends_with_nocase: String
  account_: Account_filter
  blockNumber: Int
  blockNumber_not: Int
  blockNumber_gt: Int
  blockNumber_lt: Int
  blockNumber_gte: Int
  blockNumber_lte: Int
  blockNumber_in: [Int!]
  blockNumber_not_in: [Int!]
  triggeredDate: BigInt
  triggeredDate_not: BigInt
  triggeredDate_gt: BigInt
  triggeredDate_lt: BigInt
  triggeredDate_gte: BigInt
  triggeredDate_lte: BigInt
  triggeredDate_in: [BigInt!]
  triggeredDate_not_in: [BigInt!]
  transactionID: Bytes
  transactionID_not: Bytes
  transactionID_in: [Bytes!]
  transactionID_not_in: [Bytes!]
  transactionID_contains: Bytes
  transactionID_not_contains: Bytes

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum AccountEvent_orderBy {
  id
  account
  blockNumber
  triggeredDate
  transactionID
}

input Account_filter {
  id: Bytes
  id_not: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  domains_: Domain_filter
  authorities_: AuthorisationChanged_filter
  authoriseds_: AuthorisationChanged_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum Account_orderBy {
  id
  domains
  authorities
  authoriseds
  registrations
  events
}

type Approval implements AccountEvent {
  id: ID!
  account: Account!
  blockNumber: Int!
  triggeredDate: BigInt!
  transactionID: Bytes!
  operator: Account!
  tokens: Domain!
}

input Approval_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  account: String
  account_not: String
  account_gt: String
  account_lt: String
  account_gte: String
  account_lte: String
  account_in: [String!]
  account_not_in: [String!]
  account_contains: String
  account_contains_nocase: String
  account_not_contains: String
  account_not_contains_nocase: String
  account_starts_with: String
  account_starts_with_nocase: String
  account_not_starts_with: String
  account_not_starts_with_nocase: String
  account_ends_with: String
  account_ends_with_nocase: String
  account_not_ends_with: String
  account_not_ends_with_nocase: String
  account_: Account_filter
  blockNumber: Int
  blockNumber_not: Int
  blockNumber_gt: Int
  blockNumber_lt: Int
  blockNumber_gte: Int
  blockNumber_lte: Int
  blockNumber_in: [Int!]
  blockNumber_not_in: [Int!]
  triggeredDate: BigInt
  triggeredDate_not: BigInt
  triggeredDate_gt: BigInt
  triggeredDate_lt: BigInt
  triggeredDate_gte: BigInt
  triggeredDate_lte: BigInt
  triggeredDate_in: [BigInt!]
  triggeredDate_not_in: [BigInt!]
  transactionID: Bytes
  transactionID_not: Bytes
  transactionID_in: [Bytes!]
  transactionID_not_in: [Bytes!]
  transactionID_contains: Bytes
  transactionID_not_contains: Bytes
  operator: String
  operator_not: String
  operator_gt: String
  operator_lt: String
  operator_gte: String
  operator_lte: String
  operator_in: [String!]
  operator_not_in: [String!]
  operator_contains: String
  operator_contains_nocase: String
  operator_not_contains: String
  operator_not_contains_nocase: String
  operator_starts_with: String
  operator_starts_with_nocase: String
  operator_not_starts_with: String
  operator_not_starts_with_nocase: String
  operator_ends_with: String
  operator_ends_with_nocase: String
  operator_not_ends_with: String
  operator_not_ends_with_nocase: String
  operator_: Account_filter
  tokens: String
  tokens_not: String
  tokens_gt: String
  tokens_lt: String
  tokens_gte: String
  tokens_lte: String
  tokens_in: [String!]
  tokens_not_in: [String!]
  tokens_contains: String
  tokens_contains_nocase: String
  tokens_not_contains: String
  tokens_not_contains_nocase: String
  tokens_starts_with: String
  tokens_starts_with_nocase: String
  tokens_not_starts_with: String
  tokens_not_starts_with_nocase: String
  tokens_ends_with: String
  tokens_ends_with_nocase: String
  tokens_not_ends_with: String
  tokens_not_ends_with_nocase: String
  tokens_: Domain_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum Approval_orderBy {
  id
  account
  blockNumber
  triggeredDate
  transactionID
  operator
  tokens
}

type AuthorisationChanged {
  id: ID!
  blockNumber: Int!
  triggeredDate: BigInt!
  transactionID: Bytes!
  owner: Account!
  target: Account!
  isAuthorized: Boolean!
}

input AuthorisationChanged_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  blockNumber: Int
  blockNumber_not: Int
  blockNumber_gt: Int
  blockNumber_lt: Int
  blockNumber_gte: Int
  blockNumber_lte: Int
  blockNumber_in: [Int!]
  blockNumber_not_in: [Int!]
  triggeredDate: BigInt
  triggeredDate_not: BigInt
  triggeredDate_gt: BigInt
  triggeredDate_lt: BigInt
  triggeredDate_gte: BigInt
  triggeredDate_lte: BigInt
  triggeredDate_in: [BigInt!]
  triggeredDate_not_in: [BigInt!]
  transactionID: Bytes
  transactionID_not: Bytes
  transactionID_in: [Bytes!]
  transactionID_not_in: [Bytes!]
  transactionID_contains: Bytes
  transactionID_not_contains: Bytes
  owner: String
  owner_not: String
  owner_gt: String
  owner_lt: String
  owner_gte: String
  owner_lte: String
  owner_in: [String!]
  owner_not_in: [String!]
  owner_contains: String
  owner_contains_nocase: String
  owner_not_contains: String
  owner_not_contains_nocase: String
  owner_starts_with: String
  owner_starts_with_nocase: String
  owner_not_starts_with: String
  owner_not_starts_with_nocase: String
  owner_ends_with: String
  owner_ends_with_nocase: String
  owner_not_ends_with: String
  owner_not_ends_with_nocase: String
  owner_: Account_filter
  target: String
  target_not: String
  target_gt: String
  target_lt: String
  target_gte: String
  target_lte: String
  target_in: [String!]
  target_not_in: [String!]
  target_contains: String
  target_contains_nocase: String
  target_not_contains: String
  target_not_contains_nocase: String
  target_starts_with: String
  target_starts_with_nocase: String
  target_not_starts_with: String
  target_not_starts_with_nocase: String
  target_ends_with: String
  target_ends_with_nocase: String
  target_not_ends_with: String
  target_not_ends_with_nocase: String
  target_: Account_filter
  isAuthorized: Boolean
  isAuthorized_not: Boolean
  isAuthorized_in: [Boolean!]
  isAuthorized_not_in: [Boolean!]

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum AuthorisationChanged_orderBy {
  id
  blockNumber
  triggeredDate
  transactionID
  owner
  target
  isAuthorized
}

scalar BigDecimal

scalar BigInt

input BlockChangedFilter {
  number_gte: Int!
}

input Block_height {
  hash: Bytes
  number: Int
  number_gte: Int
}

scalar Bytes

type CapacityUpdated implements RegistrationEvent {
  id: ID!
  registration: Registration!
  blockNumber: Int!
  triggeredDate: BigInt!
  transactionID: Bytes!
  registrant: Account!
  domain: Domain!
  capacity: BigInt!
}

input CapacityUpdated_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  registration: String
  registration_not: String
  registration_gt: String
  registration_lt: String
  registration_gte: String
  registration_lte: String
  registration_in: [String!]
  registration_not_in: [String!]
  registration_contains: String
  registration_contains_nocase: String
  registration_not_contains: String
  registration_not_contains_nocase: String
  registration_starts_with: String
  registration_starts_with_nocase: String
  registration_not_starts_with: String
  registration_not_starts_with_nocase: String
  registration_ends_with: String
  registration_ends_with_nocase: String
  registration_not_ends_with: String
  registration_not_ends_with_nocase: String
  registration_: Registration_filter
  blockNumber: Int
  blockNumber_not: Int
  blockNumber_gt: Int
  blockNumber_lt: Int
  blockNumber_gte: Int
  blockNumber_lte: Int
  blockNumber_in: [Int!]
  blockNumber_not_in: [Int!]
  triggeredDate: BigInt
  triggeredDate_not: BigInt
  triggeredDate_gt: BigInt
  triggeredDate_lt: BigInt
  triggeredDate_gte: BigInt
  triggeredDate_lte: BigInt
  triggeredDate_in: [BigInt!]
  triggeredDate_not_in: [BigInt!]
  transactionID: Bytes
  transactionID_not: Bytes
  transactionID_in: [Bytes!]
  transactionID_not_in: [Bytes!]
  transactionID_contains: Bytes
  transactionID_not_contains: Bytes
  registrant: String
  registrant_not: String
  registrant_gt: String
  registrant_lt: String
  registrant_gte: String
  registrant_lte: String
  registrant_in: [String!]
  registrant_not_in: [String!]
  registrant_contains: String
  registrant_contains_nocase: String
  registrant_not_contains: String
  registrant_not_contains_nocase: String
  registrant_starts_with: String
  registrant_starts_with_nocase: String
  registrant_not_starts_with: String
  registrant_not_starts_with_nocase: String
  registrant_ends_with: String
  registrant_ends_with_nocase: String
  registrant_not_ends_with: String
  registrant_not_ends_with_nocase: String
  registrant_: Account_filter
  domain: String
  domain_not: String
  domain_gt: String
  domain_lt: String
  domain_gte: String
  domain_lte: String
  domain_in: [String!]
  domain_not_in: [String!]
  domain_contains: String
  domain_contains_nocase: String
  domain_not_contains: String
  domain_not_contains_nocase: String
  domain_starts_with: String
  domain_starts_with_nocase: String
  domain_not_starts_with: String
  domain_not_starts_with_nocase: String
  domain_ends_with: String
  domain_ends_with_nocase: String
  domain_not_ends_with: String
  domain_not_ends_with_nocase: String
  domain_: Domain_filter
  capacity: BigInt
  capacity_not: BigInt
  capacity_gt: BigInt
  capacity_lt: BigInt
  capacity_gte: BigInt
  capacity_lte: BigInt
  capacity_in: [BigInt!]
  capacity_not_in: [BigInt!]

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum CapacityUpdated_orderBy {
  id
  registration
  blockNumber
  triggeredDate
  transactionID
  registrant
  domain
  capacity
}

type Domain {
  id: Bytes!
  name: String
  labelName: String
  labelhash: Bytes
  parent: Domain
  subdomains(skip: Int = 0, first: Int = 100, orderBy: Domain_orderBy, orderDirection: OrderDirection, where: Domain_filter): [Domain!]
  subdomainCount: Int!
  resolvedAddress: Account
  owner: Account
  resolver: Resolver
  createdAt: BigInt!
  events(skip: Int = 0, first: Int = 100, orderBy: DomainEvent_orderBy, orderDirection: OrderDirection, where: DomainEvent_filter): [DomainEvent!]
  registrations(skip: Int = 0, first: Int = 100, orderBy: Registration_orderBy, orderDirection: OrderDirection, where: Registration_filter): [Registration!]
}

interface DomainEvent {
  id: ID!
  domain: Domain!
  blockNumber: Int!
  triggeredDate: BigInt!
  transactionID: Bytes!
}

input DomainEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  domain: String
  domain_not: String
  domain_gt: String
  domain_lt: String
  domain_gte: String
  domain_lte: String
  domain_in: [String!]
  domain_not_in: [String!]
  domain_contains: String
  domain_contains_nocase: String
  domain_not_contains: String
  domain_not_contains_nocase: String
  domain_starts_with: String
  domain_starts_with_nocase: String
  domain_not_starts_with: String
  domain_not_starts_with_nocase: String
  domain_ends_with: String
  domain_ends_with_nocase: String
  domain_not_ends_with: String
  domain_not_ends_with_nocase: String
  domain_: Domain_filter
  blockNumber: Int
  blockNumber_not: Int
  blockNumber_gt: Int
  blockNumber_lt: Int
  blockNumber_gte: Int
  blockNumber_lte: Int
  blockNumber_in: [Int!]
  blockNumber_not_in: [Int!]
  triggeredDate: BigInt
  triggeredDate_not: BigInt
  triggeredDate_gt: BigInt
  triggeredDate_lt: BigInt
  triggeredDate_gte: BigInt
  triggeredDate_lte: BigInt
  triggeredDate_in: [BigInt!]
  triggeredDate_not_in: [BigInt!]
  transactionID: Bytes
  transactionID_not: Bytes
  transactionID_in: [Bytes!]
  transactionID_not_in: [Bytes!]
  transactionID_contains: Bytes
  transactionID_not_contains: Bytes

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum DomainEvent_orderBy {
  id
  domain
  blockNumber
  triggeredDate
  transactionID
}

input Domain_filter {
  id: Bytes
  id_not: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  labelName: String
  labelName_not: String
  labelName_gt: String
  labelName_lt: String
  labelName_gte: String
  labelName_lte: String
  labelName_in: [String!]
  labelName_not_in: [String!]
  labelName_contains: String
  labelName_contains_nocase: String
  labelName_not_contains: String
  labelName_not_contains_nocase: String
  labelName_starts_with: String
  labelName_starts_with_nocase: String
  labelName_not_starts_with: String
  labelName_not_starts_with_nocase: String
  labelName_ends_with: String
  labelName_ends_with_nocase: String
  labelName_not_ends_with: String
  labelName_not_ends_with_nocase: String
  labelhash: Bytes
  labelhash_not: Bytes
  labelhash_in: [Bytes!]
  labelhash_not_in: [Bytes!]
  labelhash_contains: Bytes
  labelhash_not_contains: Bytes
  parent: String
  parent_not: String
  parent_gt: String
  parent_lt: String
  parent_gte: String
  parent_lte: String
  parent_in: [String!]
  parent_not_in: [String!]
  parent_contains: String
  parent_contains_nocase: String
  parent_not_contains: String
  parent_not_contains_nocase: String
  parent_starts_with: String
  parent_starts_with_nocase: String
  parent_not_starts_with: String
  parent_not_starts_with_nocase: String
  parent_ends_with: String
  parent_ends_with_nocase: String
  parent_not_ends_with: String
  parent_not_ends_with_nocase: String
  parent_: Domain_filter
  subdomains_: Domain_filter
  subdomainCount: Int
  subdomainCount_not: Int
  subdomainCount_gt: Int
  subdomainCount_lt: Int
  subdomainCount_gte: Int
  subdomainCount_lte: Int
  subdomainCount_in: [Int!]
  subdomainCount_not_in: [Int!]
  resolvedAddress: String
  resolvedAddress_not: String
  resolvedAddress_gt: String
  resolvedAddress_lt: String
  resolvedAddress_gte: String
  resolvedAddress_lte: String
  resolvedAddress_in: [String!]
  resolvedAddress_not_in: [String!]
  resolvedAddress_contains: String
  resolvedAddress_contains_nocase: String
  resolvedAddress_not_contains: String
  resolvedAddress_not_contains_nocase: String
  resolvedAddress_starts_with: String
  resolvedAddress_starts_with_nocase: String
  resolvedAddress_not_starts_with: String
  resolvedAddress_not_starts_with_nocase: String
  resolvedAddress_ends_with: String
  resolvedAddress_ends_with_nocase: String
  resolvedAddress_not_ends_with: String
  resolvedAddress_not_ends_with_nocase: String
  resolvedAddress_: Account_filter
  owner: String
  owner_not: String
  owner_gt: String
  owner_lt: String
  owner_gte: String
  owner_lte: String
  owner_in: [String!]
  owner_not_in: [String!]
  owner_contains: String
  owner_contains_nocase: String
  owner_not_contains: String
  owner_not_contains_nocase: String
  owner_starts_with: String
  owner_starts_with_nocase: String
  owner_not_starts_with: String
  owner_not_starts_with_nocase: String
  owner_ends_with: String
  owner_ends_with_nocase: String
  owner_not_ends_with: String
  owner_not_ends_with_nocase: String
  owner_: Account_filter
  resolver: String
  resolver_not: String
  resolver_gt: String
  resolver_lt: String
  resolver_gte: String
  resolver_lte: String
  resolver_in: [String!]
  resolver_not_in: [String!]
  resolver_contains: String
  resolver_contains_nocase: String
  resolver_not_contains: String
  resolver_not_contains_nocase: String
  resolver_starts_with: String
  resolver_starts_with_nocase: String
  resolver_not_starts_with: String
  resolver_not_starts_with_nocase: String
  resolver_ends_with: String
  resolver_ends_with_nocase: String
  resolver_not_ends_with: String
  resolver_not_ends_with_nocase: String
  resolver_: Resolver_filter
  createdAt: BigInt
  createdAt_not: BigInt
  createdAt_gt: BigInt
  createdAt_lt: BigInt
  createdAt_gte: BigInt
  createdAt_lte: BigInt
  createdAt_in: [BigInt!]
  createdAt_not_in: [BigInt!]
  registrations_: Registration_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum Domain_orderBy {
  id
  name
  labelName
  labelhash
  parent
  subdomains
  subdomainCount
  resolvedAddress
  owner
  resolver
  createdAt
  events
  registrations
}

type NameRegistered implements RegistrationEvent {
  id: ID!
  registration: Registration!
  blockNumber: Int!
  triggeredDate: BigInt!
  transactionID: Bytes!
  registrant: Account!
  expiryDate: BigInt!
  cost: BigInt
}

input NameRegistered_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  registration: String
  registration_not: String
  registration_gt: String
  registration_lt: String
  registration_gte: String
  registration_lte: String
  registration_in: [String!]
  registration_not_in: [String!]
  registration_contains: String
  registration_contains_nocase: String
  registration_not_contains: String
  registration_not_contains_nocase: String
  registration_starts_with: String
  registration_starts_with_nocase: String
  registration_not_starts_with: String
  registration_not_starts_with_nocase: String
  registration_ends_with: String
  registration_ends_with_nocase: String
  registration_not_ends_with: String
  registration_not_ends_with_nocase: String
  registration_: Registration_filter
  blockNumber: Int
  blockNumber_not: Int
  blockNumber_gt: Int
  blockNumber_lt: Int
  blockNumber_gte: Int
  blockNumber_lte: Int
  blockNumber_in: [Int!]
  blockNumber_not_in: [Int!]
  triggeredDate: BigInt
  triggeredDate_not: BigInt
  triggeredDate_gt: BigInt
  triggeredDate_lt: BigInt
  triggeredDate_gte: BigInt
  triggeredDate_lte: BigInt
  triggeredDate_in: [BigInt!]
  triggeredDate_not_in: [BigInt!]
  transactionID: Bytes
  transactionID_not: Bytes
  transactionID_in: [Bytes!]
  transactionID_not_in: [Bytes!]
  transactionID_contains: Bytes
  transactionID_not_contains: Bytes
  registrant: String
  registrant_not: String
  registrant_gt: String
  registrant_lt: String
  registrant_gte: String
  registrant_lte: String
  registrant_in: [String!]
  registrant_not_in: [String!]
  registrant_contains: String
  registrant_contains_nocase: String
  registrant_not_contains: String
  registrant_not_contains_nocase: String
  registrant_starts_with: String
  registrant_starts_with_nocase: String
  registrant_not_starts_with: String
  registrant_not_starts_with_nocase: String
  registrant_ends_with: String
  registrant_ends_with_nocase: String
  registrant_not_ends_with: String
  registrant_not_ends_with_nocase: String
  registrant_: Account_filter
  expiryDate: BigInt
  expiryDate_not: BigInt
  expiryDate_gt: BigInt
  expiryDate_lt: BigInt
  expiryDate_gte: BigInt
  expiryDate_lte: BigInt
  expiryDate_in: [BigInt!]
  expiryDate_not_in: [BigInt!]
  cost: BigInt
  cost_not: BigInt
  cost_gt: BigInt
  cost_lt: BigInt
  cost_gte: BigInt
  cost_lte: BigInt
  cost_in: [BigInt!]
  cost_not_in: [BigInt!]

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum NameRegistered_orderBy {
  id
  registration
  blockNumber
  triggeredDate
  transactionID
  registrant
  expiryDate
  cost
}

type NameRenewed implements RegistrationEvent {
  id: ID!
  registration: Registration!
  blockNumber: Int!
  triggeredDate: BigInt!
  transactionID: Bytes!
  registrant: Account!
  expiryDate: BigInt!
  cost: BigInt
}

input NameRenewed_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  registration: String
  registration_not: String
  registration_gt: String
  registration_lt: String
  registration_gte: String
  registration_lte: String
  registration_in: [String!]
  registration_not_in: [String!]
  registration_contains: String
  registration_contains_nocase: String
  registration_not_contains: String
  registration_not_contains_nocase: String
  registration_starts_with: String
  registration_starts_with_nocase: String
  registration_not_starts_with: String
  registration_not_starts_with_nocase: String
  registration_ends_with: String
  registration_ends_with_nocase: String
  registration_not_ends_with: String
  registration_not_ends_with_nocase: String
  registration_: Registration_filter
  blockNumber: Int
  blockNumber_not: Int
  blockNumber_gt: Int
  blockNumber_lt: Int
  blockNumber_gte: Int
  blockNumber_lte: Int
  blockNumber_in: [Int!]
  blockNumber_not_in: [Int!]
  triggeredDate: BigInt
  triggeredDate_not: BigInt
  triggeredDate_gt: BigInt
  triggeredDate_lt: BigInt
  triggeredDate_gte: BigInt
  triggeredDate_lte: BigInt
  triggeredDate_in: [BigInt!]
  triggeredDate_not_in: [BigInt!]
  transactionID: Bytes
  transactionID_not: Bytes
  transactionID_in: [Bytes!]
  transactionID_not_in: [Bytes!]
  transactionID_contains: Bytes
  transactionID_not_contains: Bytes
  registrant: String
  registrant_not: String
  registrant_gt: String
  registrant_lt: String
  registrant_gte: String
  registrant_lte: String
  registrant_in: [String!]
  registrant_not_in: [String!]
  registrant_contains: String
  registrant_contains_nocase: String
  registrant_not_contains: String
  registrant_not_contains_nocase: String
  registrant_starts_with: String
  registrant_starts_with_nocase: String
  registrant_not_starts_with: String
  registrant_not_starts_with_nocase: String
  registrant_ends_with: String
  registrant_ends_with_nocase: String
  registrant_not_ends_with: String
  registrant_not_ends_with_nocase: String
  registrant_: Account_filter
  expiryDate: BigInt
  expiryDate_not: BigInt
  expiryDate_gt: BigInt
  expiryDate_lt: BigInt
  expiryDate_gte: BigInt
  expiryDate_lte: BigInt
  expiryDate_in: [BigInt!]
  expiryDate_not_in: [BigInt!]
  cost: BigInt
  cost_not: BigInt
  cost_gt: BigInt
  cost_lt: BigInt
  cost_gte: BigInt
  cost_lte: BigInt
  cost_in: [BigInt!]
  cost_not_in: [BigInt!]

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum NameRenewed_orderBy {
  id
  registration
  blockNumber
  triggeredDate
  transactionID
  registrant
  expiryDate
  cost
}

type NewResolver implements DomainEvent {
  id: ID!
  domain: Domain!
  blockNumber: Int!
  triggeredDate: BigInt!
  transactionID: Bytes!
  resolver: Resolver!
}

input NewResolver_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  domain: String
  domain_not: String
  domain_gt: String
  domain_lt: String
  domain_gte: String
  domain_lte: String
  domain_in: [String!]
  domain_not_in: [String!]
  domain_contains: String
  domain_contains_nocase: String
  domain_not_contains: String
  domain_not_contains_nocase: String
  domain_starts_with: String
  domain_starts_with_nocase: String
  domain_not_starts_with: String
  domain_not_starts_with_nocase: String
  domain_ends_with: String
  domain_ends_with_nocase: String
  domain_not_ends_with: String
  domain_not_ends_with_nocase: String
  domain_: Domain_filter
  blockNumber: Int
  blockNumber_not: Int
  blockNumber_gt: Int
  blockNumber_lt: Int
  blockNumber_gte: Int
  blockNumber_lte: Int
  blockNumber_in: [Int!]
  blockNumber_not_in: [Int!]
  triggeredDate: BigInt
  triggeredDate_not: BigInt
  triggeredDate_gt: BigInt
  triggeredDate_lt: BigInt
  triggeredDate_gte: BigInt
  triggeredDate_lte: BigInt
  triggeredDate_in: [BigInt!]
  triggeredDate_not_in: [BigInt!]
  transactionID: Bytes
  transactionID_not: Bytes
  transactionID_in: [Bytes!]
  transactionID_not_in: [Bytes!]
  transactionID_contains: Bytes
  transactionID_not_contains: Bytes
  resolver: String
  resolver_not: String
  resolver_gt: String
  resolver_lt: String
  resolver_gte: String
  resolver_lte: String
  resolver_in: [String!]
  resolver_not_in: [String!]
  resolver_contains: String
  resolver_contains_nocase: String
  resolver_not_contains: String
  resolver_not_contains_nocase: String
  resolver_starts_with: String
  resolver_starts_with_nocase: String
  resolver_not_starts_with: String
  resolver_not_starts_with_nocase: String
  resolver_ends_with: String
  resolver_ends_with_nocase: String
  resolver_not_ends_with: String
  resolver_not_ends_with_nocase: String
  resolver_: Resolver_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum NewResolver_orderBy {
  id
  domain
  blockNumber
  triggeredDate
  transactionID
  resolver
}

type NewSubdomain implements DomainEvent {
  id: ID!
  domain: Domain!
  blockNumber: Int!
  triggeredDate: BigInt!
  transactionID: Bytes!
  to: Account!
  parentId: Domain!
  name: String!
}

input NewSubdomain_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  domain: String
  domain_not: String
  domain_gt: String
  domain_lt: String
  domain_gte: String
  domain_lte: String
  domain_in: [String!]
  domain_not_in: [String!]
  domain_contains: String
  domain_contains_nocase: String
  domain_not_contains: String
  domain_not_contains_nocase: String
  domain_starts_with: String
  domain_starts_with_nocase: String
  domain_not_starts_with: String
  domain_not_starts_with_nocase: String
  domain_ends_with: String
  domain_ends_with_nocase: String
  domain_not_ends_with: String
  domain_not_ends_with_nocase: String
  domain_: Domain_filter
  blockNumber: Int
  blockNumber_not: Int
  blockNumber_gt: Int
  blockNumber_lt: Int
  blockNumber_gte: Int
  blockNumber_lte: Int
  blockNumber_in: [Int!]
  blockNumber_not_in: [Int!]
  triggeredDate: BigInt
  triggeredDate_not: BigInt
  triggeredDate_gt: BigInt
  triggeredDate_lt: BigInt
  triggeredDate_gte: BigInt
  triggeredDate_lte: BigInt
  triggeredDate_in: [BigInt!]
  triggeredDate_not_in: [BigInt!]
  transactionID: Bytes
  transactionID_not: Bytes
  transactionID_in: [Bytes!]
  transactionID_not_in: [Bytes!]
  transactionID_contains: Bytes
  transactionID_not_contains: Bytes
  to: String
  to_not: String
  to_gt: String
  to_lt: String
  to_gte: String
  to_lte: String
  to_in: [String!]
  to_not_in: [String!]
  to_contains: String
  to_contains_nocase: String
  to_not_contains: String
  to_not_contains_nocase: String
  to_starts_with: String
  to_starts_with_nocase: String
  to_not_starts_with: String
  to_not_starts_with_nocase: String
  to_ends_with: String
  to_ends_with_nocase: String
  to_not_ends_with: String
  to_not_ends_with_nocase: String
  to_: Account_filter
  parentId: String
  parentId_not: String
  parentId_gt: String
  parentId_lt: String
  parentId_gte: String
  parentId_lte: String
  parentId_in: [String!]
  parentId_not_in: [String!]
  parentId_contains: String
  parentId_contains_nocase: String
  parentId_not_contains: String
  parentId_not_contains_nocase: String
  parentId_starts_with: String
  parentId_starts_with_nocase: String
  parentId_not_starts_with: String
  parentId_not_starts_with_nocase: String
  parentId_ends_with: String
  parentId_ends_with_nocase: String
  parentId_not_ends_with: String
  parentId_not_ends_with_nocase: String
  parentId_: Domain_filter
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum NewSubdomain_orderBy {
  id
  domain
  blockNumber
  triggeredDate
  transactionID
  to
  parentId
  name
}

"""Defines the order direction, either ascending or descending"""
enum OrderDirection {
  asc
  desc
}

type PriceChanged {
  id: ID!
  blockNumber: Int!
  triggeredDate: BigInt!
  transactionID: Bytes!
  basePrices: [BigInt!]!
  rentPrices: [BigInt!]!
}

input PriceChanged_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  blockNumber: Int
  blockNumber_not: Int
  blockNumber_gt: Int
  blockNumber_lt: Int
  blockNumber_gte: Int
  blockNumber_lte: Int
  blockNumber_in: [Int!]
  blockNumber_not_in: [Int!]
  triggeredDate: BigInt
  triggeredDate_not: BigInt
  triggeredDate_gt: BigInt
  triggeredDate_lt: BigInt
  triggeredDate_gte: BigInt
  triggeredDate_lte: BigInt
  triggeredDate_in: [BigInt!]
  triggeredDate_not_in: [BigInt!]
  transactionID: Bytes
  transactionID_not: Bytes
  transactionID_in: [Bytes!]
  transactionID_not_in: [Bytes!]
  transactionID_contains: Bytes
  transactionID_not_contains: Bytes
  basePrices: [BigInt!]
  basePrices_not: [BigInt!]
  basePrices_contains: [BigInt!]
  basePrices_contains_nocase: [BigInt!]
  basePrices_not_contains: [BigInt!]
  basePrices_not_contains_nocase: [BigInt!]
  rentPrices: [BigInt!]
  rentPrices_not: [BigInt!]
  rentPrices_contains: [BigInt!]
  rentPrices_contains_nocase: [BigInt!]
  rentPrices_not_contains: [BigInt!]
  rentPrices_not_contains_nocase: [BigInt!]

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum PriceChanged_orderBy {
  id
  blockNumber
  triggeredDate
  transactionID
  basePrices
  rentPrices
}

type Query {
  domain(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Domain
  domains(
    skip: Int = 0
    first: Int = 100
    orderBy: Domain_orderBy
    orderDirection: OrderDirection
    where: Domain_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Domain!]!
  setNftName(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SetNftName
  setNftNames(
    skip: Int = 0
    first: Int = 100
    orderBy: SetNftName_orderBy
    orderDirection: OrderDirection
    where: SetNftName_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SetNftName!]!
  set(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Set
  sets(
    skip: Int = 0
    first: Int = 100
    orderBy: Set_orderBy
    orderDirection: OrderDirection
    where: Set_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Set!]!
  setLink(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SetLink
  setLinks(
    skip: Int = 0
    first: Int = 100
    orderBy: SetLink_orderBy
    orderDirection: OrderDirection
    where: SetLink_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SetLink!]!
  transfer(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Transfer
  transfers(
    skip: Int = 0
    first: Int = 100
    orderBy: Transfer_orderBy
    orderDirection: OrderDirection
    where: Transfer_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Transfer!]!
  newSubdomain(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): NewSubdomain
  newSubdomains(
    skip: Int = 0
    first: Int = 100
    orderBy: NewSubdomain_orderBy
    orderDirection: OrderDirection
    where: NewSubdomain_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [NewSubdomain!]!
  newResolver(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): NewResolver
  newResolvers(
    skip: Int = 0
    first: Int = 100
    orderBy: NewResolver_orderBy
    orderDirection: OrderDirection
    where: NewResolver_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [NewResolver!]!
  account(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Account
  accounts(
    skip: Int = 0
    first: Int = 100
    orderBy: Account_orderBy
    orderDirection: OrderDirection
    where: Account_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Account!]!
  setName(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SetName
  setNames(
    skip: Int = 0
    first: Int = 100
    orderBy: SetName_orderBy
    orderDirection: OrderDirection
    where: SetName_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SetName!]!
  approval(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Approval
  approvals(
    skip: Int = 0
    first: Int = 100
    orderBy: Approval_orderBy
    orderDirection: OrderDirection
    where: Approval_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Approval!]!
  registration(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Registration
  registrations(
    skip: Int = 0
    first: Int = 100
    orderBy: Registration_orderBy
    orderDirection: OrderDirection
    where: Registration_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Registration!]!
  capacityUpdated(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CapacityUpdated
  capacityUpdateds(
    skip: Int = 0
    first: Int = 100
    orderBy: CapacityUpdated_orderBy
    orderDirection: OrderDirection
    where: CapacityUpdated_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [CapacityUpdated!]!
  nameRegistered(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): NameRegistered
  nameRegistereds(
    skip: Int = 0
    first: Int = 100
    orderBy: NameRegistered_orderBy
    orderDirection: OrderDirection
    where: NameRegistered_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [NameRegistered!]!
  nameRenewed(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): NameRenewed
  nameReneweds(
    skip: Int = 0
    first: Int = 100
    orderBy: NameRenewed_orderBy
    orderDirection: OrderDirection
    where: NameRenewed_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [NameRenewed!]!
  priceChanged(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PriceChanged
  priceChangeds(
    skip: Int = 0
    first: Int = 100
    orderBy: PriceChanged_orderBy
    orderDirection: OrderDirection
    where: PriceChanged_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [PriceChanged!]!
  resolver(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Resolver
  resolvers(
    skip: Int = 0
    first: Int = 100
    orderBy: Resolver_orderBy
    orderDirection: OrderDirection
    where: Resolver_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Resolver!]!
  authorisationChanged(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AuthorisationChanged
  authorisationChangeds(
    skip: Int = 0
    first: Int = 100
    orderBy: AuthorisationChanged_orderBy
    orderDirection: OrderDirection
    where: AuthorisationChanged_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AuthorisationChanged!]!
  domainEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DomainEvent
  domainEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: DomainEvent_orderBy
    orderDirection: OrderDirection
    where: DomainEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [DomainEvent!]!
  accountEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AccountEvent
  accountEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: AccountEvent_orderBy
    orderDirection: OrderDirection
    where: AccountEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AccountEvent!]!
  registrationEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RegistrationEvent
  registrationEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: RegistrationEvent_orderBy
    orderDirection: OrderDirection
    where: RegistrationEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [RegistrationEvent!]!
  resolverEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ResolverEvent
  resolverEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: ResolverEvent_orderBy
    orderDirection: OrderDirection
    where: ResolverEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ResolverEvent!]!

  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
}

type Registration {
  id: Bytes!
  domain: Domain!
  origin: Domain
  expiryDate: BigInt
  capacity: BigInt
  labelName: String
  events(skip: Int = 0, first: Int = 100, orderBy: RegistrationEvent_orderBy, orderDirection: OrderDirection, where: RegistrationEvent_filter): [RegistrationEvent!]!
}

interface RegistrationEvent {
  id: ID!
  registration: Registration!
  blockNumber: Int!
  triggeredDate: BigInt!
  transactionID: Bytes!
  registrant: Account!
}

input RegistrationEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  registration: String
  registration_not: String
  registration_gt: String
  registration_lt: String
  registration_gte: String
  registration_lte: String
  registration_in: [String!]
  registration_not_in: [String!]
  registration_contains: String
  registration_contains_nocase: String
  registration_not_contains: String
  registration_not_contains_nocase: String
  registration_starts_with: String
  registration_starts_with_nocase: String
  registration_not_starts_with: String
  registration_not_starts_with_nocase: String
  registration_ends_with: String
  registration_ends_with_nocase: String
  registration_not_ends_with: String
  registration_not_ends_with_nocase: String
  registration_: Registration_filter
  blockNumber: Int
  blockNumber_not: Int
  blockNumber_gt: Int
  blockNumber_lt: Int
  blockNumber_gte: Int
  blockNumber_lte: Int
  blockNumber_in: [Int!]
  blockNumber_not_in: [Int!]
  triggeredDate: BigInt
  triggeredDate_not: BigInt
  triggeredDate_gt: BigInt
  triggeredDate_lt: BigInt
  triggeredDate_gte: BigInt
  triggeredDate_lte: BigInt
  triggeredDate_in: [BigInt!]
  triggeredDate_not_in: [BigInt!]
  transactionID: Bytes
  transactionID_not: Bytes
  transactionID_in: [Bytes!]
  transactionID_not_in: [Bytes!]
  transactionID_contains: Bytes
  transactionID_not_contains: Bytes
  registrant: String
  registrant_not: String
  registrant_gt: String
  registrant_lt: String
  registrant_gte: String
  registrant_lte: String
  registrant_in: [String!]
  registrant_not_in: [String!]
  registrant_contains: String
  registrant_contains_nocase: String
  registrant_not_contains: String
  registrant_not_contains_nocase: String
  registrant_starts_with: String
  registrant_starts_with_nocase: String
  registrant_not_starts_with: String
  registrant_not_starts_with_nocase: String
  registrant_ends_with: String
  registrant_ends_with_nocase: String
  registrant_not_ends_with: String
  registrant_not_ends_with_nocase: String
  registrant_: Account_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum RegistrationEvent_orderBy {
  id
  registration
  blockNumber
  triggeredDate
  transactionID
  registrant
}

input Registration_filter {
  id: Bytes
  id_not: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  domain: String
  domain_not: String
  domain_gt: String
  domain_lt: String
  domain_gte: String
  domain_lte: String
  domain_in: [String!]
  domain_not_in: [String!]
  domain_contains: String
  domain_contains_nocase: String
  domain_not_contains: String
  domain_not_contains_nocase: String
  domain_starts_with: String
  domain_starts_with_nocase: String
  domain_not_starts_with: String
  domain_not_starts_with_nocase: String
  domain_ends_with: String
  domain_ends_with_nocase: String
  domain_not_ends_with: String
  domain_not_ends_with_nocase: String
  domain_: Domain_filter
  origin: String
  origin_not: String
  origin_gt: String
  origin_lt: String
  origin_gte: String
  origin_lte: String
  origin_in: [String!]
  origin_not_in: [String!]
  origin_contains: String
  origin_contains_nocase: String
  origin_not_contains: String
  origin_not_contains_nocase: String
  origin_starts_with: String
  origin_starts_with_nocase: String
  origin_not_starts_with: String
  origin_not_starts_with_nocase: String
  origin_ends_with: String
  origin_ends_with_nocase: String
  origin_not_ends_with: String
  origin_not_ends_with_nocase: String
  origin_: Domain_filter
  expiryDate: BigInt
  expiryDate_not: BigInt
  expiryDate_gt: BigInt
  expiryDate_lt: BigInt
  expiryDate_gte: BigInt
  expiryDate_lte: BigInt
  expiryDate_in: [BigInt!]
  expiryDate_not_in: [BigInt!]
  capacity: BigInt
  capacity_not: BigInt
  capacity_gt: BigInt
  capacity_lt: BigInt
  capacity_gte: BigInt
  capacity_lte: BigInt
  capacity_in: [BigInt!]
  capacity_not_in: [BigInt!]
  labelName: String
  labelName_not: String
  labelName_gt: String
  labelName_lt: String
  labelName_gte: String
  labelName_lte: String
  labelName_in: [String!]
  labelName_not_in: [String!]
  labelName_contains: String
  labelName_contains_nocase: String
  labelName_not_contains: String
  labelName_not_contains_nocase: String
  labelName_starts_with: String
  labelName_starts_with_nocase: String
  labelName_not_starts_with: String
  labelName_not_starts_with_nocase: String
  labelName_ends_with: String
  labelName_ends_with_nocase: String
  labelName_not_ends_with: String
  labelName_not_ends_with_nocase: String

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum Registration_orderBy {
  id
  domain
  origin
  expiryDate
  capacity
  labelName
  events
}

type Resolver {
  id: ID!
  domain: Domain
  address: Bytes!
  addr: Account
  contentHash: Bytes
  texts: [String!]
  coinTypes: [BigInt!]
  events(skip: Int = 0, first: Int = 100, orderBy: ResolverEvent_orderBy, orderDirection: OrderDirection, where: ResolverEvent_filter): [ResolverEvent!]!
}

interface ResolverEvent {
  id: ID!
  resolver: Resolver!
  blockNumber: Int!
  triggeredDate: BigInt!
  transactionID: Bytes!
}

input ResolverEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  resolver: String
  resolver_not: String
  resolver_gt: String
  resolver_lt: String
  resolver_gte: String
  resolver_lte: String
  resolver_in: [String!]
  resolver_not_in: [String!]
  resolver_contains: String
  resolver_contains_nocase: String
  resolver_not_contains: String
  resolver_not_contains_nocase: String
  resolver_starts_with: String
  resolver_starts_with_nocase: String
  resolver_not_starts_with: String
  resolver_not_starts_with_nocase: String
  resolver_ends_with: String
  resolver_ends_with_nocase: String
  resolver_not_ends_with: String
  resolver_not_ends_with_nocase: String
  resolver_: Resolver_filter
  blockNumber: Int
  blockNumber_not: Int
  blockNumber_gt: Int
  blockNumber_lt: Int
  blockNumber_gte: Int
  blockNumber_lte: Int
  blockNumber_in: [Int!]
  blockNumber_not_in: [Int!]
  triggeredDate: BigInt
  triggeredDate_not: BigInt
  triggeredDate_gt: BigInt
  triggeredDate_lt: BigInt
  triggeredDate_gte: BigInt
  triggeredDate_lte: BigInt
  triggeredDate_in: [BigInt!]
  triggeredDate_not_in: [BigInt!]
  transactionID: Bytes
  transactionID_not: Bytes
  transactionID_in: [Bytes!]
  transactionID_not_in: [Bytes!]
  transactionID_contains: Bytes
  transactionID_not_contains: Bytes

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum ResolverEvent_orderBy {
  id
  resolver
  blockNumber
  triggeredDate
  transactionID
}

input Resolver_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  domain: String
  domain_not: String
  domain_gt: String
  domain_lt: String
  domain_gte: String
  domain_lte: String
  domain_in: [String!]
  domain_not_in: [String!]
  domain_contains: String
  domain_contains_nocase: String
  domain_not_contains: String
  domain_not_contains_nocase: String
  domain_starts_with: String
  domain_starts_with_nocase: String
  domain_not_starts_with: String
  domain_not_starts_with_nocase: String
  domain_ends_with: String
  domain_ends_with_nocase: String
  domain_not_ends_with: String
  domain_not_ends_with_nocase: String
  domain_: Domain_filter
  address: Bytes
  address_not: Bytes
  address_in: [Bytes!]
  address_not_in: [Bytes!]
  address_contains: Bytes
  address_not_contains: Bytes
  addr: String
  addr_not: String
  addr_gt: String
  addr_lt: String
  addr_gte: String
  addr_lte: String
  addr_in: [String!]
  addr_not_in: [String!]
  addr_contains: String
  addr_contains_nocase: String
  addr_not_contains: String
  addr_not_contains_nocase: String
  addr_starts_with: String
  addr_starts_with_nocase: String
  addr_not_starts_with: String
  addr_not_starts_with_nocase: String
  addr_ends_with: String
  addr_ends_with_nocase: String
  addr_not_ends_with: String
  addr_not_ends_with_nocase: String
  addr_: Account_filter
  contentHash: Bytes
  contentHash_not: Bytes
  contentHash_in: [Bytes!]
  contentHash_not_in: [Bytes!]
  contentHash_contains: Bytes
  contentHash_not_contains: Bytes
  texts: [String!]
  texts_not: [String!]
  texts_contains: [String!]
  texts_contains_nocase: [String!]
  texts_not_contains: [String!]
  texts_not_contains_nocase: [String!]
  coinTypes: [BigInt!]
  coinTypes_not: [BigInt!]
  coinTypes_contains: [BigInt!]
  coinTypes_contains_nocase: [BigInt!]
  coinTypes_not_contains: [BigInt!]
  coinTypes_not_contains_nocase: [BigInt!]

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum Resolver_orderBy {
  id
  domain
  address
  addr
  contentHash
  texts
  coinTypes
  events
}

type Set implements DomainEvent {
  id: ID!
  domain: Domain!
  blockNumber: Int!
  triggeredDate: BigInt!
  transactionID: Bytes!
  keyHash: BigInt!
  value: String!
}

type SetLink implements DomainEvent {
  id: ID!
  domain: Domain!
  blockNumber: Int!
  triggeredDate: BigInt!
  transactionID: Bytes!
  keyHash: BigInt!
  value: BigInt!
}

input SetLink_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  domain: String
  domain_not: String
  domain_gt: String
  domain_lt: String
  domain_gte: String
  domain_lte: String
  domain_in: [String!]
  domain_not_in: [String!]
  domain_contains: String
  domain_contains_nocase: String
  domain_not_contains: String
  domain_not_contains_nocase: String
  domain_starts_with: String
  domain_starts_with_nocase: String
  domain_not_starts_with: String
  domain_not_starts_with_nocase: String
  domain_ends_with: String
  domain_ends_with_nocase: String
  domain_not_ends_with: String
  domain_not_ends_with_nocase: String
  domain_: Domain_filter
  blockNumber: Int
  blockNumber_not: Int
  blockNumber_gt: Int
  blockNumber_lt: Int
  blockNumber_gte: Int
  blockNumber_lte: Int
  blockNumber_in: [Int!]
  blockNumber_not_in: [Int!]
  triggeredDate: BigInt
  triggeredDate_not: BigInt
  triggeredDate_gt: BigInt
  triggeredDate_lt: BigInt
  triggeredDate_gte: BigInt
  triggeredDate_lte: BigInt
  triggeredDate_in: [BigInt!]
  triggeredDate_not_in: [BigInt!]
  transactionID: Bytes
  transactionID_not: Bytes
  transactionID_in: [Bytes!]
  transactionID_not_in: [Bytes!]
  transactionID_contains: Bytes
  transactionID_not_contains: Bytes
  keyHash: BigInt
  keyHash_not: BigInt
  keyHash_gt: BigInt
  keyHash_lt: BigInt
  keyHash_gte: BigInt
  keyHash_lte: BigInt
  keyHash_in: [BigInt!]
  keyHash_not_in: [BigInt!]
  value: BigInt
  value_not: BigInt
  value_gt: BigInt
  value_lt: BigInt
  value_gte: BigInt
  value_lte: BigInt
  value_in: [BigInt!]
  value_not_in: [BigInt!]

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum SetLink_orderBy {
  id
  domain
  blockNumber
  triggeredDate
  transactionID
  keyHash
  value
}

type SetName implements AccountEvent {
  id: ID!
  account: Account!
  blockNumber: Int!
  triggeredDate: BigInt!
  transactionID: Bytes!
  tokenId: Domain!
}

input SetName_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  account: String
  account_not: String
  account_gt: String
  account_lt: String
  account_gte: String
  account_lte: String
  account_in: [String!]
  account_not_in: [String!]
  account_contains: String
  account_contains_nocase: String
  account_not_contains: String
  account_not_contains_nocase: String
  account_starts_with: String
  account_starts_with_nocase: String
  account_not_starts_with: String
  account_not_starts_with_nocase: String
  account_ends_with: String
  account_ends_with_nocase: String
  account_not_ends_with: String
  account_not_ends_with_nocase: String
  account_: Account_filter
  blockNumber: Int
  blockNumber_not: Int
  blockNumber_gt: Int
  blockNumber_lt: Int
  blockNumber_gte: Int
  blockNumber_lte: Int
  blockNumber_in: [Int!]
  blockNumber_not_in: [Int!]
  triggeredDate: BigInt
  triggeredDate_not: BigInt
  triggeredDate_gt: BigInt
  triggeredDate_lt: BigInt
  triggeredDate_gte: BigInt
  triggeredDate_lte: BigInt
  triggeredDate_in: [BigInt!]
  triggeredDate_not_in: [BigInt!]
  transactionID: Bytes
  transactionID_not: Bytes
  transactionID_in: [Bytes!]
  transactionID_not_in: [Bytes!]
  transactionID_contains: Bytes
  transactionID_not_contains: Bytes
  tokenId: String
  tokenId_not: String
  tokenId_gt: String
  tokenId_lt: String
  tokenId_gte: String
  tokenId_lte: String
  tokenId_in: [String!]
  tokenId_not_in: [String!]
  tokenId_contains: String
  tokenId_contains_nocase: String
  tokenId_not_contains: String
  tokenId_not_contains_nocase: String
  tokenId_starts_with: String
  tokenId_starts_with_nocase: String
  tokenId_not_starts_with: String
  tokenId_not_starts_with_nocase: String
  tokenId_ends_with: String
  tokenId_ends_with_nocase: String
  tokenId_not_ends_with: String
  tokenId_not_ends_with_nocase: String
  tokenId_: Domain_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum SetName_orderBy {
  id
  account
  blockNumber
  triggeredDate
  transactionID
  tokenId
}

type SetNftName implements DomainEvent {
  id: ID!
  domain: Domain!
  blockNumber: Int!
  triggeredDate: BigInt!
  transactionID: Bytes!
  nftAddr: Account!
  nftTokenId: BigInt!
}

input SetNftName_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  domain: String
  domain_not: String
  domain_gt: String
  domain_lt: String
  domain_gte: String
  domain_lte: String
  domain_in: [String!]
  domain_not_in: [String!]
  domain_contains: String
  domain_contains_nocase: String
  domain_not_contains: String
  domain_not_contains_nocase: String
  domain_starts_with: String
  domain_starts_with_nocase: String
  domain_not_starts_with: String
  domain_not_starts_with_nocase: String
  domain_ends_with: String
  domain_ends_with_nocase: String
  domain_not_ends_with: String
  domain_not_ends_with_nocase: String
  domain_: Domain_filter
  blockNumber: Int
  blockNumber_not: Int
  blockNumber_gt: Int
  blockNumber_lt: Int
  blockNumber_gte: Int
  blockNumber_lte: Int
  blockNumber_in: [Int!]
  blockNumber_not_in: [Int!]
  triggeredDate: BigInt
  triggeredDate_not: BigInt
  triggeredDate_gt: BigInt
  triggeredDate_lt: BigInt
  triggeredDate_gte: BigInt
  triggeredDate_lte: BigInt
  triggeredDate_in: [BigInt!]
  triggeredDate_not_in: [BigInt!]
  transactionID: Bytes
  transactionID_not: Bytes
  transactionID_in: [Bytes!]
  transactionID_not_in: [Bytes!]
  transactionID_contains: Bytes
  transactionID_not_contains: Bytes
  nftAddr: String
  nftAddr_not: String
  nftAddr_gt: String
  nftAddr_lt: String
  nftAddr_gte: String
  nftAddr_lte: String
  nftAddr_in: [String!]
  nftAddr_not_in: [String!]
  nftAddr_contains: String
  nftAddr_contains_nocase: String
  nftAddr_not_contains: String
  nftAddr_not_contains_nocase: String
  nftAddr_starts_with: String
  nftAddr_starts_with_nocase: String
  nftAddr_not_starts_with: String
  nftAddr_not_starts_with_nocase: String
  nftAddr_ends_with: String
  nftAddr_ends_with_nocase: String
  nftAddr_not_ends_with: String
  nftAddr_not_ends_with_nocase: String
  nftAddr_: Account_filter
  nftTokenId: BigInt
  nftTokenId_not: BigInt
  nftTokenId_gt: BigInt
  nftTokenId_lt: BigInt
  nftTokenId_gte: BigInt
  nftTokenId_lte: BigInt
  nftTokenId_in: [BigInt!]
  nftTokenId_not_in: [BigInt!]

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum SetNftName_orderBy {
  id
  domain
  blockNumber
  triggeredDate
  transactionID
  nftAddr
  nftTokenId
}

input Set_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  domain: String
  domain_not: String
  domain_gt: String
  domain_lt: String
  domain_gte: String
  domain_lte: String
  domain_in: [String!]
  domain_not_in: [String!]
  domain_contains: String
  domain_contains_nocase: String
  domain_not_contains: String
  domain_not_contains_nocase: String
  domain_starts_with: String
  domain_starts_with_nocase: String
  domain_not_starts_with: String
  domain_not_starts_with_nocase: String
  domain_ends_with: String
  domain_ends_with_nocase: String
  domain_not_ends_with: String
  domain_not_ends_with_nocase: String
  domain_: Domain_filter
  blockNumber: Int
  blockNumber_not: Int
  blockNumber_gt: Int
  blockNumber_lt: Int
  blockNumber_gte: Int
  blockNumber_lte: Int
  blockNumber_in: [Int!]
  blockNumber_not_in: [Int!]
  triggeredDate: BigInt
  triggeredDate_not: BigInt
  triggeredDate_gt: BigInt
  triggeredDate_lt: BigInt
  triggeredDate_gte: BigInt
  triggeredDate_lte: BigInt
  triggeredDate_in: [BigInt!]
  triggeredDate_not_in: [BigInt!]
  transactionID: Bytes
  transactionID_not: Bytes
  transactionID_in: [Bytes!]
  transactionID_not_in: [Bytes!]
  transactionID_contains: Bytes
  transactionID_not_contains: Bytes
  keyHash: BigInt
  keyHash_not: BigInt
  keyHash_gt: BigInt
  keyHash_lt: BigInt
  keyHash_gte: BigInt
  keyHash_lte: BigInt
  keyHash_in: [BigInt!]
  keyHash_not_in: [BigInt!]
  value: String
  value_not: String
  value_gt: String
  value_lt: String
  value_gte: String
  value_lte: String
  value_in: [String!]
  value_not_in: [String!]
  value_contains: String
  value_contains_nocase: String
  value_not_contains: String
  value_not_contains_nocase: String
  value_starts_with: String
  value_starts_with_nocase: String
  value_not_starts_with: String
  value_not_starts_with_nocase: String
  value_ends_with: String
  value_ends_with_nocase: String
  value_not_ends_with: String
  value_not_ends_with_nocase: String

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum Set_orderBy {
  id
  domain
  blockNumber
  triggeredDate
  transactionID
  keyHash
  value
}

type Subscription {
  domain(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Domain
  domains(
    skip: Int = 0
    first: Int = 100
    orderBy: Domain_orderBy
    orderDirection: OrderDirection
    where: Domain_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Domain!]!
  setNftName(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SetNftName
  setNftNames(
    skip: Int = 0
    first: Int = 100
    orderBy: SetNftName_orderBy
    orderDirection: OrderDirection
    where: SetNftName_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SetNftName!]!
  set(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Set
  sets(
    skip: Int = 0
    first: Int = 100
    orderBy: Set_orderBy
    orderDirection: OrderDirection
    where: Set_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Set!]!
  setLink(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SetLink
  setLinks(
    skip: Int = 0
    first: Int = 100
    orderBy: SetLink_orderBy
    orderDirection: OrderDirection
    where: SetLink_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SetLink!]!
  transfer(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Transfer
  transfers(
    skip: Int = 0
    first: Int = 100
    orderBy: Transfer_orderBy
    orderDirection: OrderDirection
    where: Transfer_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Transfer!]!
  newSubdomain(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): NewSubdomain
  newSubdomains(
    skip: Int = 0
    first: Int = 100
    orderBy: NewSubdomain_orderBy
    orderDirection: OrderDirection
    where: NewSubdomain_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [NewSubdomain!]!
  newResolver(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): NewResolver
  newResolvers(
    skip: Int = 0
    first: Int = 100
    orderBy: NewResolver_orderBy
    orderDirection: OrderDirection
    where: NewResolver_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [NewResolver!]!
  account(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Account
  accounts(
    skip: Int = 0
    first: Int = 100
    orderBy: Account_orderBy
    orderDirection: OrderDirection
    where: Account_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Account!]!
  setName(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SetName
  setNames(
    skip: Int = 0
    first: Int = 100
    orderBy: SetName_orderBy
    orderDirection: OrderDirection
    where: SetName_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SetName!]!
  approval(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Approval
  approvals(
    skip: Int = 0
    first: Int = 100
    orderBy: Approval_orderBy
    orderDirection: OrderDirection
    where: Approval_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Approval!]!
  registration(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Registration
  registrations(
    skip: Int = 0
    first: Int = 100
    orderBy: Registration_orderBy
    orderDirection: OrderDirection
    where: Registration_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Registration!]!
  capacityUpdated(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CapacityUpdated
  capacityUpdateds(
    skip: Int = 0
    first: Int = 100
    orderBy: CapacityUpdated_orderBy
    orderDirection: OrderDirection
    where: CapacityUpdated_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [CapacityUpdated!]!
  nameRegistered(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): NameRegistered
  nameRegistereds(
    skip: Int = 0
    first: Int = 100
    orderBy: NameRegistered_orderBy
    orderDirection: OrderDirection
    where: NameRegistered_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [NameRegistered!]!
  nameRenewed(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): NameRenewed
  nameReneweds(
    skip: Int = 0
    first: Int = 100
    orderBy: NameRenewed_orderBy
    orderDirection: OrderDirection
    where: NameRenewed_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [NameRenewed!]!
  priceChanged(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PriceChanged
  priceChangeds(
    skip: Int = 0
    first: Int = 100
    orderBy: PriceChanged_orderBy
    orderDirection: OrderDirection
    where: PriceChanged_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [PriceChanged!]!
  resolver(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Resolver
  resolvers(
    skip: Int = 0
    first: Int = 100
    orderBy: Resolver_orderBy
    orderDirection: OrderDirection
    where: Resolver_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Resolver!]!
  authorisationChanged(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AuthorisationChanged
  authorisationChangeds(
    skip: Int = 0
    first: Int = 100
    orderBy: AuthorisationChanged_orderBy
    orderDirection: OrderDirection
    where: AuthorisationChanged_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AuthorisationChanged!]!
  domainEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DomainEvent
  domainEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: DomainEvent_orderBy
    orderDirection: OrderDirection
    where: DomainEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [DomainEvent!]!
  accountEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AccountEvent
  accountEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: AccountEvent_orderBy
    orderDirection: OrderDirection
    where: AccountEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AccountEvent!]!
  registrationEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RegistrationEvent
  registrationEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: RegistrationEvent_orderBy
    orderDirection: OrderDirection
    where: RegistrationEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [RegistrationEvent!]!
  resolverEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ResolverEvent
  resolverEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: ResolverEvent_orderBy
    orderDirection: OrderDirection
    where: ResolverEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ResolverEvent!]!

  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
}

type Transfer implements DomainEvent {
  id: ID!
  domain: Domain!
  blockNumber: Int!
  triggeredDate: BigInt!
  transactionID: Bytes!
  from: Account
  to: Account!
}

input Transfer_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  domain: String
  domain_not: String
  domain_gt: String
  domain_lt: String
  domain_gte: String
  domain_lte: String
  domain_in: [String!]
  domain_not_in: [String!]
  domain_contains: String
  domain_contains_nocase: String
  domain_not_contains: String
  domain_not_contains_nocase: String
  domain_starts_with: String
  domain_starts_with_nocase: String
  domain_not_starts_with: String
  domain_not_starts_with_nocase: String
  domain_ends_with: String
  domain_ends_with_nocase: String
  domain_not_ends_with: String
  domain_not_ends_with_nocase: String
  domain_: Domain_filter
  blockNumber: Int
  blockNumber_not: Int
  blockNumber_gt: Int
  blockNumber_lt: Int
  blockNumber_gte: Int
  blockNumber_lte: Int
  blockNumber_in: [Int!]
  blockNumber_not_in: [Int!]
  triggeredDate: BigInt
  triggeredDate_not: BigInt
  triggeredDate_gt: BigInt
  triggeredDate_lt: BigInt
  triggeredDate_gte: BigInt
  triggeredDate_lte: BigInt
  triggeredDate_in: [BigInt!]
  triggeredDate_not_in: [BigInt!]
  transactionID: Bytes
  transactionID_not: Bytes
  transactionID_in: [Bytes!]
  transactionID_not_in: [Bytes!]
  transactionID_contains: Bytes
  transactionID_not_contains: Bytes
  from: String
  from_not: String
  from_gt: String
  from_lt: String
  from_gte: String
  from_lte: String
  from_in: [String!]
  from_not_in: [String!]
  from_contains: String
  from_contains_nocase: String
  from_not_contains: String
  from_not_contains_nocase: String
  from_starts_with: String
  from_starts_with_nocase: String
  from_not_starts_with: String
  from_not_starts_with_nocase: String
  from_ends_with: String
  from_ends_with_nocase: String
  from_not_ends_with: String
  from_not_ends_with_nocase: String
  from_: Account_filter
  to: String
  to_not: String
  to_gt: String
  to_lt: String
  to_gte: String
  to_lte: String
  to_in: [String!]
  to_not_in: [String!]
  to_contains: String
  to_contains_nocase: String
  to_not_contains: String
  to_not_contains_nocase: String
  to_starts_with: String
  to_starts_with_nocase: String
  to_not_starts_with: String
  to_not_starts_with_nocase: String
  to_ends_with: String
  to_ends_with_nocase: String
  to_not_ends_with: String
  to_not_ends_with_nocase: String
  to_: Account_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum Transfer_orderBy {
  id
  domain
  blockNumber
  triggeredDate
  transactionID
  from
  to
}

type _Block_ {
  """The hash of the block"""
  hash: Bytes

  """The block number"""
  number: Int!

  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
}

"""The type for the top-level _meta field"""
type _Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: _Block_!

  """The deployment ID"""
  deployment: String!

  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

enum _SubgraphErrorPolicy_ {
  """Data will be returned even if the subgraph has indexing errors"""
  allow

  """
  If the subgraph has indexing errors, data will be omitted. The default.
  """
  deny
}

