"""Exposes a URL that specifies the behaviour of this scalar."""
directive @specifiedBy(
  """The URL that specifies the behaviour of this scalar."""
  url: String!
) on SCALAR

type _Metadata {
  lastProcessedHeight: Int
  lastProcessedTimestamp: Date
  targetHeight: Int
  chain: String
  specName: String
  genesisHash: String
  indexerHealthy: Boolean
  indexerNodeVersion: String
  queryNodeVersion: String
  rowCountEstimate: [TableEstimate]
  dynamicDatasources: String
}

type Approval implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: String!
  owner: String
  approved: String
  node: String
}

type ApprovalAggregates {
  keys: [String!]
}

"""
A filter to be used against `Approval` object types. All fields are combined with a logical ‘and.’
"""
input ApprovalFilter {
  """Filter by the object’s `id` field."""
  id: StringFilter

  """Filter by the object’s `owner` field."""
  owner: StringFilter

  """Filter by the object’s `approved` field."""
  approved: StringFilter

  """Filter by the object’s `node` field."""
  node: StringFilter

  """Checks for all expressions in this list."""
  and: [ApprovalFilter!]

  """Checks for any expressions in this list."""
  or: [ApprovalFilter!]

  """Negates the expression."""
  not: ApprovalFilter
}

type ApprovalForAll implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: String!
  owner: String
  operator: String
  approved: Boolean
}

type ApprovalForAllAggregates {
  keys: [String!]
}

"""
A filter to be used against `ApprovalForAll` object types. All fields are combined with a logical ‘and.’
"""
input ApprovalForAllFilter {
  """Filter by the object’s `id` field."""
  id: StringFilter

  """Filter by the object’s `owner` field."""
  owner: StringFilter

  """Filter by the object’s `operator` field."""
  operator: StringFilter

  """Filter by the object’s `approved` field."""
  approved: BooleanFilter

  """Checks for all expressions in this list."""
  and: [ApprovalForAllFilter!]

  """Checks for any expressions in this list."""
  or: [ApprovalForAllFilter!]

  """Negates the expression."""
  not: ApprovalForAllFilter
}

"""A connection to a list of `ApprovalForAll` values."""
type ApprovalForAllsConnection {
  """A list of `ApprovalForAll` objects."""
  nodes: [ApprovalForAll]!

  """
  A list of edges which contains the `ApprovalForAll` and cursor to aid in pagination.
  """
  edges: [ApprovalForAllsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `ApprovalForAll` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: ApprovalForAllAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `ApprovalForAll` for these aggregates."""
    groupBy: [ApprovalForAllsGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: ApprovalForAllsHavingInput
  ): [ApprovalForAllAggregates!]
}

"""A `ApprovalForAll` edge in the connection."""
type ApprovalForAllsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `ApprovalForAll` at the end of the edge."""
  node: ApprovalForAll
}

"""Grouping methods for `ApprovalForAll` for usage during aggregation."""
enum ApprovalForAllsGroupBy {
  OWNER
  OPERATOR
  APPROVED
}

"""Conditions for `ApprovalForAll` aggregates."""
input ApprovalForAllsHavingInput {
  AND: [ApprovalForAllsHavingInput!]
  OR: [ApprovalForAllsHavingInput!]
}

"""Methods to use when ordering `ApprovalForAll`."""
enum ApprovalForAllsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  OWNER_ASC
  OWNER_DESC
  OPERATOR_ASC
  OPERATOR_DESC
  APPROVED_ASC
  APPROVED_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""A connection to a list of `Approval` values."""
type ApprovalsConnection {
  """A list of `Approval` objects."""
  nodes: [Approval]!

  """
  A list of edges which contains the `Approval` and cursor to aid in pagination.
  """
  edges: [ApprovalsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Approval` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: ApprovalAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `Approval` for these aggregates."""
    groupBy: [ApprovalsGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: ApprovalsHavingInput
  ): [ApprovalAggregates!]
}

"""A `Approval` edge in the connection."""
type ApprovalsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Approval` at the end of the edge."""
  node: Approval
}

"""Grouping methods for `Approval` for usage during aggregation."""
enum ApprovalsGroupBy {
  OWNER
  APPROVED
  NODE
}

"""Conditions for `Approval` aggregates."""
input ApprovalsHavingInput {
  AND: [ApprovalsHavingInput!]
  OR: [ApprovalsHavingInput!]
}

"""Methods to use when ordering `Approval`."""
enum ApprovalsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  OWNER_ASC
  OWNER_DESC
  APPROVED_ASC
  APPROVED_DESC
  NODE_ASC
  NODE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A filter to be used against Boolean fields. All fields are combined with a logical ‘and.’
"""
input BooleanFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: Boolean

  """Not equal to the specified value."""
  notEqualTo: Boolean

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: Boolean

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: Boolean

  """Included in the specified list."""
  in: [Boolean!]

  """Not included in the specified list."""
  notIn: [Boolean!]

  """Less than the specified value."""
  lessThan: Boolean

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: Boolean

  """Greater than the specified value."""
  greaterThan: Boolean

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: Boolean
}

type CapacityChanged implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: String!
  node: String
  capacity: String
}

type CapacityChangedAggregates {
  keys: [String!]
}

"""
A filter to be used against `CapacityChanged` object types. All fields are combined with a logical ‘and.’
"""
input CapacityChangedFilter {
  """Filter by the object’s `id` field."""
  id: StringFilter

  """Filter by the object’s `node` field."""
  node: StringFilter

  """Filter by the object’s `capacity` field."""
  capacity: StringFilter

  """Checks for all expressions in this list."""
  and: [CapacityChangedFilter!]

  """Checks for any expressions in this list."""
  or: [CapacityChangedFilter!]

  """Negates the expression."""
  not: CapacityChangedFilter
}

"""A connection to a list of `CapacityChanged` values."""
type CapacityChangedsConnection {
  """A list of `CapacityChanged` objects."""
  nodes: [CapacityChanged]!

  """
  A list of edges which contains the `CapacityChanged` and cursor to aid in pagination.
  """
  edges: [CapacityChangedsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `CapacityChanged` you could get from the connection.
  """
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: CapacityChangedAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """
    The method to use when grouping `CapacityChanged` for these aggregates.
    """
    groupBy: [CapacityChangedsGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: CapacityChangedsHavingInput
  ): [CapacityChangedAggregates!]
}

"""A `CapacityChanged` edge in the connection."""
type CapacityChangedsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `CapacityChanged` at the end of the edge."""
  node: CapacityChanged
}

"""Grouping methods for `CapacityChanged` for usage during aggregation."""
enum CapacityChangedsGroupBy {
  NODE
  CAPACITY
}

"""Conditions for `CapacityChanged` aggregates."""
input CapacityChangedsHavingInput {
  AND: [CapacityChangedsHavingInput!]
  OR: [CapacityChangedsHavingInput!]
}

"""Methods to use when ordering `CapacityChanged`."""
enum CapacityChangedsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  NODE_ASC
  NODE_DESC
  CAPACITY_ASC
  CAPACITY_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

type ControllerConfigUpdated implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: String!
  flags: String
}

type ControllerConfigUpdatedAggregates {
  keys: [String!]
}

"""
A filter to be used against `ControllerConfigUpdated` object types. All fields are combined with a logical ‘and.’
"""
input ControllerConfigUpdatedFilter {
  """Filter by the object’s `id` field."""
  id: StringFilter

  """Filter by the object’s `flags` field."""
  flags: StringFilter

  """Checks for all expressions in this list."""
  and: [ControllerConfigUpdatedFilter!]

  """Checks for any expressions in this list."""
  or: [ControllerConfigUpdatedFilter!]

  """Negates the expression."""
  not: ControllerConfigUpdatedFilter
}

"""A connection to a list of `ControllerConfigUpdated` values."""
type ControllerConfigUpdatedsConnection {
  """A list of `ControllerConfigUpdated` objects."""
  nodes: [ControllerConfigUpdated]!

  """
  A list of edges which contains the `ControllerConfigUpdated` and cursor to aid in pagination.
  """
  edges: [ControllerConfigUpdatedsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `ControllerConfigUpdated` you could get from the connection.
  """
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: ControllerConfigUpdatedAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """
    The method to use when grouping `ControllerConfigUpdated` for these aggregates.
    """
    groupBy: [ControllerConfigUpdatedsGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: ControllerConfigUpdatedsHavingInput
  ): [ControllerConfigUpdatedAggregates!]
}

"""A `ControllerConfigUpdated` edge in the connection."""
type ControllerConfigUpdatedsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `ControllerConfigUpdated` at the end of the edge."""
  node: ControllerConfigUpdated
}

"""
Grouping methods for `ControllerConfigUpdated` for usage during aggregation.
"""
enum ControllerConfigUpdatedsGroupBy {
  FLAGS
}

"""Conditions for `ControllerConfigUpdated` aggregates."""
input ControllerConfigUpdatedsHavingInput {
  AND: [ControllerConfigUpdatedsHavingInput!]
  OR: [ControllerConfigUpdatedsHavingInput!]
}

"""Methods to use when ordering `ControllerConfigUpdated`."""
enum ControllerConfigUpdatedsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  FLAGS_ASC
  FLAGS_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""A location in a connection that can be used for resuming pagination."""
scalar Cursor

"""The day, does not include a time."""
scalar Date

"""
A filter to be used against Int fields. All fields are combined with a logical ‘and.’
"""
input IntFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: Int

  """Not equal to the specified value."""
  notEqualTo: Int

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: Int

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: Int

  """Included in the specified list."""
  in: [Int!]

  """Not included in the specified list."""
  notIn: [Int!]

  """Less than the specified value."""
  lessThan: Int

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: Int

  """Greater than the specified value."""
  greaterThan: Int

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: Int
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON

"""
A filter to be used against JSON fields. All fields are combined with a logical ‘and.’
"""
input JSONFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: JSON

  """Not equal to the specified value."""
  notEqualTo: JSON

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: JSON

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: JSON

  """Included in the specified list."""
  in: [JSON!]

  """Not included in the specified list."""
  notIn: [JSON!]

  """Less than the specified value."""
  lessThan: JSON

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: JSON

  """Greater than the specified value."""
  greaterThan: JSON

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: JSON

  """Contains the specified JSON."""
  contains: JSON

  """Contains the specified key."""
  containsKey: String

  """Contains all of the specified keys."""
  containsAllKeys: [String!]

  """Contains any of the specified keys."""
  containsAnyKeys: [String!]

  """Contained by the specified JSON."""
  containedBy: JSON
}

type ManagerChanged implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: String!
  manager: String
  role: Boolean
}

type ManagerChangedAggregates {
  keys: [String!]
}

"""
A filter to be used against `ManagerChanged` object types. All fields are combined with a logical ‘and.’
"""
input ManagerChangedFilter {
  """Filter by the object’s `id` field."""
  id: StringFilter

  """Filter by the object’s `manager` field."""
  manager: StringFilter

  """Filter by the object’s `role` field."""
  role: BooleanFilter

  """Checks for all expressions in this list."""
  and: [ManagerChangedFilter!]

  """Checks for any expressions in this list."""
  or: [ManagerChangedFilter!]

  """Negates the expression."""
  not: ManagerChangedFilter
}

"""A connection to a list of `ManagerChanged` values."""
type ManagerChangedsConnection {
  """A list of `ManagerChanged` objects."""
  nodes: [ManagerChanged]!

  """
  A list of edges which contains the `ManagerChanged` and cursor to aid in pagination.
  """
  edges: [ManagerChangedsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `ManagerChanged` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: ManagerChangedAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `ManagerChanged` for these aggregates."""
    groupBy: [ManagerChangedsGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: ManagerChangedsHavingInput
  ): [ManagerChangedAggregates!]
}

"""A `ManagerChanged` edge in the connection."""
type ManagerChangedsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `ManagerChanged` at the end of the edge."""
  node: ManagerChanged
}

"""Grouping methods for `ManagerChanged` for usage during aggregation."""
enum ManagerChangedsGroupBy {
  MANAGER
  ROLE
}

"""Conditions for `ManagerChanged` aggregates."""
input ManagerChangedsHavingInput {
  AND: [ManagerChangedsHavingInput!]
  OR: [ManagerChangedsHavingInput!]
}

"""Methods to use when ordering `ManagerChanged`."""
enum ManagerChangedsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  MANAGER_ASC
  MANAGER_DESC
  ROLE_ASC
  ROLE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

type MetadataUpdated implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: String!
  data: JSON
}

type MetadataUpdatedAggregates {
  keys: [String!]
}

"""
A filter to be used against `MetadataUpdated` object types. All fields are combined with a logical ‘and.’
"""
input MetadataUpdatedFilter {
  """Filter by the object’s `id` field."""
  id: StringFilter

  """Filter by the object’s `data` field."""
  data: JSONFilter

  """Checks for all expressions in this list."""
  and: [MetadataUpdatedFilter!]

  """Checks for any expressions in this list."""
  or: [MetadataUpdatedFilter!]

  """Negates the expression."""
  not: MetadataUpdatedFilter
}

"""A connection to a list of `MetadataUpdated` values."""
type MetadataUpdatedsConnection {
  """A list of `MetadataUpdated` objects."""
  nodes: [MetadataUpdated]!

  """
  A list of edges which contains the `MetadataUpdated` and cursor to aid in pagination.
  """
  edges: [MetadataUpdatedsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `MetadataUpdated` you could get from the connection.
  """
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: MetadataUpdatedAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """
    The method to use when grouping `MetadataUpdated` for these aggregates.
    """
    groupBy: [MetadataUpdatedsGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: MetadataUpdatedsHavingInput
  ): [MetadataUpdatedAggregates!]
}

"""A `MetadataUpdated` edge in the connection."""
type MetadataUpdatedsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `MetadataUpdated` at the end of the edge."""
  node: MetadataUpdated
}

"""Grouping methods for `MetadataUpdated` for usage during aggregation."""
enum MetadataUpdatedsGroupBy {
  DATA
}

"""Conditions for `MetadataUpdated` aggregates."""
input MetadataUpdatedsHavingInput {
  AND: [MetadataUpdatedsHavingInput!]
  OR: [MetadataUpdatedsHavingInput!]
}

"""Methods to use when ordering `MetadataUpdated`."""
enum MetadataUpdatedsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  DATA_ASC
  DATA_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

type NameRedeem implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: String!
  name: String
  owner: String
  duration: String
  deadline: String
  code: String
  success: Boolean
  timestamp: Int
  from: String
}

type NameRedeemAggregates {
  keys: [String!]
}

"""
A filter to be used against `NameRedeem` object types. All fields are combined with a logical ‘and.’
"""
input NameRedeemFilter {
  """Filter by the object’s `id` field."""
  id: StringFilter

  """Filter by the object’s `name` field."""
  name: StringFilter

  """Filter by the object’s `owner` field."""
  owner: StringFilter

  """Filter by the object’s `duration` field."""
  duration: StringFilter

  """Filter by the object’s `deadline` field."""
  deadline: StringFilter

  """Filter by the object’s `code` field."""
  code: StringFilter

  """Filter by the object’s `success` field."""
  success: BooleanFilter

  """Filter by the object’s `timestamp` field."""
  timestamp: IntFilter

  """Filter by the object’s `from` field."""
  from: StringFilter

  """Checks for all expressions in this list."""
  and: [NameRedeemFilter!]

  """Checks for any expressions in this list."""
  or: [NameRedeemFilter!]

  """Negates the expression."""
  not: NameRedeemFilter
}

"""A connection to a list of `NameRedeem` values."""
type NameRedeemsConnection {
  """A list of `NameRedeem` objects."""
  nodes: [NameRedeem]!

  """
  A list of edges which contains the `NameRedeem` and cursor to aid in pagination.
  """
  edges: [NameRedeemsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `NameRedeem` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: NameRedeemAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `NameRedeem` for these aggregates."""
    groupBy: [NameRedeemsGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: NameRedeemsHavingInput
  ): [NameRedeemAggregates!]
}

"""A `NameRedeem` edge in the connection."""
type NameRedeemsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `NameRedeem` at the end of the edge."""
  node: NameRedeem
}

"""Grouping methods for `NameRedeem` for usage during aggregation."""
enum NameRedeemsGroupBy {
  NAME
  OWNER
  DURATION
  DEADLINE
  CODE
  SUCCESS
  TIMESTAMP
  FROM
}

"""Conditions for `NameRedeem` aggregates."""
input NameRedeemsHavingInput {
  AND: [NameRedeemsHavingInput!]
  OR: [NameRedeemsHavingInput!]
}

"""Methods to use when ordering `NameRedeem`."""
enum NameRedeemsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  OWNER_ASC
  OWNER_DESC
  DURATION_ASC
  DURATION_DESC
  DEADLINE_ASC
  DEADLINE_DESC
  CODE_ASC
  CODE_DESC
  SUCCESS_ASC
  SUCCESS_DESC
  TIMESTAMP_ASC
  TIMESTAMP_DESC
  FROM_ASC
  FROM_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

type NameRegister implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: String!
  name: String
  owner: String
  duration: String
  success: Boolean
  timestamp: Int
  from: String
}

type NameRegisterAggregates {
  keys: [String!]
}

type NameRegisterByManager implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: String!
  name: String
  owner: String
  duration: String
  success: Boolean
  timestamp: Int
  from: String
  keyHashes: JSON
  values: JSON
}

type NameRegisterByManagerAggregates {
  keys: [String!]
}

"""
A filter to be used against `NameRegisterByManager` object types. All fields are combined with a logical ‘and.’
"""
input NameRegisterByManagerFilter {
  """Filter by the object’s `id` field."""
  id: StringFilter

  """Filter by the object’s `name` field."""
  name: StringFilter

  """Filter by the object’s `owner` field."""
  owner: StringFilter

  """Filter by the object’s `duration` field."""
  duration: StringFilter

  """Filter by the object’s `success` field."""
  success: BooleanFilter

  """Filter by the object’s `timestamp` field."""
  timestamp: IntFilter

  """Filter by the object’s `from` field."""
  from: StringFilter

  """Filter by the object’s `keyHashes` field."""
  keyHashes: JSONFilter

  """Filter by the object’s `values` field."""
  values: JSONFilter

  """Checks for all expressions in this list."""
  and: [NameRegisterByManagerFilter!]

  """Checks for any expressions in this list."""
  or: [NameRegisterByManagerFilter!]

  """Negates the expression."""
  not: NameRegisterByManagerFilter
}

"""A connection to a list of `NameRegisterByManager` values."""
type NameRegisterByManagersConnection {
  """A list of `NameRegisterByManager` objects."""
  nodes: [NameRegisterByManager]!

  """
  A list of edges which contains the `NameRegisterByManager` and cursor to aid in pagination.
  """
  edges: [NameRegisterByManagersEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `NameRegisterByManager` you could get from the connection.
  """
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: NameRegisterByManagerAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """
    The method to use when grouping `NameRegisterByManager` for these aggregates.
    """
    groupBy: [NameRegisterByManagersGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: NameRegisterByManagersHavingInput
  ): [NameRegisterByManagerAggregates!]
}

"""A `NameRegisterByManager` edge in the connection."""
type NameRegisterByManagersEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `NameRegisterByManager` at the end of the edge."""
  node: NameRegisterByManager
}

"""
Grouping methods for `NameRegisterByManager` for usage during aggregation.
"""
enum NameRegisterByManagersGroupBy {
  NAME
  OWNER
  DURATION
  SUCCESS
  TIMESTAMP
  FROM
  KEY_HASHES
  VALUES
}

"""Conditions for `NameRegisterByManager` aggregates."""
input NameRegisterByManagersHavingInput {
  AND: [NameRegisterByManagersHavingInput!]
  OR: [NameRegisterByManagersHavingInput!]
}

"""Methods to use when ordering `NameRegisterByManager`."""
enum NameRegisterByManagersOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  OWNER_ASC
  OWNER_DESC
  DURATION_ASC
  DURATION_DESC
  SUCCESS_ASC
  SUCCESS_DESC
  TIMESTAMP_ASC
  TIMESTAMP_DESC
  FROM_ASC
  FROM_DESC
  KEY_HASHES_ASC
  KEY_HASHES_DESC
  VALUES_ASC
  VALUES_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

type NameRegistered implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: String!
  to: String
  node: String
  cost: String
  expires: String
  name: String
}

type NameRegisteredAggregates {
  keys: [String!]
}

"""
A filter to be used against `NameRegistered` object types. All fields are combined with a logical ‘and.’
"""
input NameRegisteredFilter {
  """Filter by the object’s `id` field."""
  id: StringFilter

  """Filter by the object’s `to` field."""
  to: StringFilter

  """Filter by the object’s `node` field."""
  node: StringFilter

  """Filter by the object’s `cost` field."""
  cost: StringFilter

  """Filter by the object’s `expires` field."""
  expires: StringFilter

  """Filter by the object’s `name` field."""
  name: StringFilter

  """Checks for all expressions in this list."""
  and: [NameRegisteredFilter!]

  """Checks for any expressions in this list."""
  or: [NameRegisteredFilter!]

  """Negates the expression."""
  not: NameRegisteredFilter
}

"""A connection to a list of `NameRegistered` values."""
type NameRegisteredsConnection {
  """A list of `NameRegistered` objects."""
  nodes: [NameRegistered]!

  """
  A list of edges which contains the `NameRegistered` and cursor to aid in pagination.
  """
  edges: [NameRegisteredsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `NameRegistered` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: NameRegisteredAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `NameRegistered` for these aggregates."""
    groupBy: [NameRegisteredsGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: NameRegisteredsHavingInput
  ): [NameRegisteredAggregates!]
}

"""A `NameRegistered` edge in the connection."""
type NameRegisteredsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `NameRegistered` at the end of the edge."""
  node: NameRegistered
}

"""Grouping methods for `NameRegistered` for usage during aggregation."""
enum NameRegisteredsGroupBy {
  TO
  NODE
  COST
  EXPIRES
  NAME
}

"""Conditions for `NameRegistered` aggregates."""
input NameRegisteredsHavingInput {
  AND: [NameRegisteredsHavingInput!]
  OR: [NameRegisteredsHavingInput!]
}

"""Methods to use when ordering `NameRegistered`."""
enum NameRegisteredsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  TO_ASC
  TO_DESC
  NODE_ASC
  NODE_DESC
  COST_ASC
  COST_DESC
  EXPIRES_ASC
  EXPIRES_DESC
  NAME_ASC
  NAME_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A filter to be used against `NameRegister` object types. All fields are combined with a logical ‘and.’
"""
input NameRegisterFilter {
  """Filter by the object’s `id` field."""
  id: StringFilter

  """Filter by the object’s `name` field."""
  name: StringFilter

  """Filter by the object’s `owner` field."""
  owner: StringFilter

  """Filter by the object’s `duration` field."""
  duration: StringFilter

  """Filter by the object’s `success` field."""
  success: BooleanFilter

  """Filter by the object’s `timestamp` field."""
  timestamp: IntFilter

  """Filter by the object’s `from` field."""
  from: StringFilter

  """Checks for all expressions in this list."""
  and: [NameRegisterFilter!]

  """Checks for any expressions in this list."""
  or: [NameRegisterFilter!]

  """Negates the expression."""
  not: NameRegisterFilter
}

"""A connection to a list of `NameRegister` values."""
type NameRegistersConnection {
  """A list of `NameRegister` objects."""
  nodes: [NameRegister]!

  """
  A list of edges which contains the `NameRegister` and cursor to aid in pagination.
  """
  edges: [NameRegistersEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `NameRegister` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: NameRegisterAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `NameRegister` for these aggregates."""
    groupBy: [NameRegistersGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: NameRegistersHavingInput
  ): [NameRegisterAggregates!]
}

"""A `NameRegister` edge in the connection."""
type NameRegistersEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `NameRegister` at the end of the edge."""
  node: NameRegister
}

"""Grouping methods for `NameRegister` for usage during aggregation."""
enum NameRegistersGroupBy {
  NAME
  OWNER
  DURATION
  SUCCESS
  TIMESTAMP
  FROM
}

"""Conditions for `NameRegister` aggregates."""
input NameRegistersHavingInput {
  AND: [NameRegistersHavingInput!]
  OR: [NameRegistersHavingInput!]
}

"""Methods to use when ordering `NameRegister`."""
enum NameRegistersOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  OWNER_ASC
  OWNER_DESC
  DURATION_ASC
  DURATION_DESC
  SUCCESS_ASC
  SUCCESS_DESC
  TIMESTAMP_ASC
  TIMESTAMP_DESC
  FROM_ASC
  FROM_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

type NameRegisterWithConfig implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: String!
  name: String
  owner: String
  success: Boolean
  timestamp: Int
  from: String
  duration: String
  keyHashes: JSON
  values: JSON
}

type NameRegisterWithConfigAggregates {
  keys: [String!]
}

"""
A filter to be used against `NameRegisterWithConfig` object types. All fields are combined with a logical ‘and.’
"""
input NameRegisterWithConfigFilter {
  """Filter by the object’s `id` field."""
  id: StringFilter

  """Filter by the object’s `name` field."""
  name: StringFilter

  """Filter by the object’s `owner` field."""
  owner: StringFilter

  """Filter by the object’s `success` field."""
  success: BooleanFilter

  """Filter by the object’s `timestamp` field."""
  timestamp: IntFilter

  """Filter by the object’s `from` field."""
  from: StringFilter

  """Filter by the object’s `duration` field."""
  duration: StringFilter

  """Filter by the object’s `keyHashes` field."""
  keyHashes: JSONFilter

  """Filter by the object’s `values` field."""
  values: JSONFilter

  """Checks for all expressions in this list."""
  and: [NameRegisterWithConfigFilter!]

  """Checks for any expressions in this list."""
  or: [NameRegisterWithConfigFilter!]

  """Negates the expression."""
  not: NameRegisterWithConfigFilter
}

"""A connection to a list of `NameRegisterWithConfig` values."""
type NameRegisterWithConfigsConnection {
  """A list of `NameRegisterWithConfig` objects."""
  nodes: [NameRegisterWithConfig]!

  """
  A list of edges which contains the `NameRegisterWithConfig` and cursor to aid in pagination.
  """
  edges: [NameRegisterWithConfigsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `NameRegisterWithConfig` you could get from the connection.
  """
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: NameRegisterWithConfigAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """
    The method to use when grouping `NameRegisterWithConfig` for these aggregates.
    """
    groupBy: [NameRegisterWithConfigsGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: NameRegisterWithConfigsHavingInput
  ): [NameRegisterWithConfigAggregates!]
}

"""A `NameRegisterWithConfig` edge in the connection."""
type NameRegisterWithConfigsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `NameRegisterWithConfig` at the end of the edge."""
  node: NameRegisterWithConfig
}

"""
Grouping methods for `NameRegisterWithConfig` for usage during aggregation.
"""
enum NameRegisterWithConfigsGroupBy {
  NAME
  OWNER
  SUCCESS
  TIMESTAMP
  FROM
  DURATION
  KEY_HASHES
  VALUES
}

"""Conditions for `NameRegisterWithConfig` aggregates."""
input NameRegisterWithConfigsHavingInput {
  AND: [NameRegisterWithConfigsHavingInput!]
  OR: [NameRegisterWithConfigsHavingInput!]
}

"""Methods to use when ordering `NameRegisterWithConfig`."""
enum NameRegisterWithConfigsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  OWNER_ASC
  OWNER_DESC
  SUCCESS_ASC
  SUCCESS_DESC
  TIMESTAMP_ASC
  TIMESTAMP_DESC
  FROM_ASC
  FROM_DESC
  DURATION_ASC
  DURATION_DESC
  KEY_HASHES_ASC
  KEY_HASHES_DESC
  VALUES_ASC
  VALUES_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

type NameRenewed implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: String!
  node: String
  cost: String
  expires: String
  name: String
}

type NameRenewedAggregates {
  keys: [String!]
}

"""
A filter to be used against `NameRenewed` object types. All fields are combined with a logical ‘and.’
"""
input NameRenewedFilter {
  """Filter by the object’s `id` field."""
  id: StringFilter

  """Filter by the object’s `node` field."""
  node: StringFilter

  """Filter by the object’s `cost` field."""
  cost: StringFilter

  """Filter by the object’s `expires` field."""
  expires: StringFilter

  """Filter by the object’s `name` field."""
  name: StringFilter

  """Checks for all expressions in this list."""
  and: [NameRenewedFilter!]

  """Checks for any expressions in this list."""
  or: [NameRenewedFilter!]

  """Negates the expression."""
  not: NameRenewedFilter
}

"""A connection to a list of `NameRenewed` values."""
type NameRenewedsConnection {
  """A list of `NameRenewed` objects."""
  nodes: [NameRenewed]!

  """
  A list of edges which contains the `NameRenewed` and cursor to aid in pagination.
  """
  edges: [NameRenewedsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `NameRenewed` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: NameRenewedAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `NameRenewed` for these aggregates."""
    groupBy: [NameRenewedsGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: NameRenewedsHavingInput
  ): [NameRenewedAggregates!]
}

"""A `NameRenewed` edge in the connection."""
type NameRenewedsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `NameRenewed` at the end of the edge."""
  node: NameRenewed
}

"""Grouping methods for `NameRenewed` for usage during aggregation."""
enum NameRenewedsGroupBy {
  NODE
  COST
  EXPIRES
  NAME
}

"""Conditions for `NameRenewed` aggregates."""
input NameRenewedsHavingInput {
  AND: [NameRenewedsHavingInput!]
  OR: [NameRenewedsHavingInput!]
}

"""Methods to use when ordering `NameRenewed`."""
enum NameRenewedsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  NODE_ASC
  NODE_DESC
  COST_ASC
  COST_DESC
  EXPIRES_ASC
  EXPIRES_DESC
  NAME_ASC
  NAME_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

type NewKey implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: String!
  keyIndex: String
  key: String
  timestamp: Int
}

type NewKeyAggregates {
  keys: [String!]
}

"""
A filter to be used against `NewKey` object types. All fields are combined with a logical ‘and.’
"""
input NewKeyFilter {
  """Filter by the object’s `id` field."""
  id: StringFilter

  """Filter by the object’s `keyIndex` field."""
  keyIndex: StringFilter

  """Filter by the object’s `key` field."""
  key: StringFilter

  """Filter by the object’s `timestamp` field."""
  timestamp: IntFilter

  """Checks for all expressions in this list."""
  and: [NewKeyFilter!]

  """Checks for any expressions in this list."""
  or: [NewKeyFilter!]

  """Negates the expression."""
  not: NewKeyFilter
}

"""A connection to a list of `NewKey` values."""
type NewKeysConnection {
  """A list of `NewKey` objects."""
  nodes: [NewKey]!

  """
  A list of edges which contains the `NewKey` and cursor to aid in pagination.
  """
  edges: [NewKeysEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `NewKey` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: NewKeyAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `NewKey` for these aggregates."""
    groupBy: [NewKeysGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: NewKeysHavingInput
  ): [NewKeyAggregates!]
}

"""A `NewKey` edge in the connection."""
type NewKeysEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `NewKey` at the end of the edge."""
  node: NewKey
}

"""Grouping methods for `NewKey` for usage during aggregation."""
enum NewKeysGroupBy {
  KEY_INDEX
  KEY
  TIMESTAMP
}

"""Conditions for `NewKey` aggregates."""
input NewKeysHavingInput {
  AND: [NewKeysHavingInput!]
  OR: [NewKeysHavingInput!]
}

"""Methods to use when ordering `NewKey`."""
enum NewKeysOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  KEY_INDEX_ASC
  KEY_INDEX_DESC
  KEY_ASC
  KEY_DESC
  TIMESTAMP_ASC
  TIMESTAMP_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

type NewResolver implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: String!
  node: String
  resolver: String
}

type NewResolverAggregates {
  keys: [String!]
}

"""
A filter to be used against `NewResolver` object types. All fields are combined with a logical ‘and.’
"""
input NewResolverFilter {
  """Filter by the object’s `id` field."""
  id: StringFilter

  """Filter by the object’s `node` field."""
  node: StringFilter

  """Filter by the object’s `resolver` field."""
  resolver: StringFilter

  """Checks for all expressions in this list."""
  and: [NewResolverFilter!]

  """Checks for any expressions in this list."""
  or: [NewResolverFilter!]

  """Negates the expression."""
  not: NewResolverFilter
}

"""A connection to a list of `NewResolver` values."""
type NewResolversConnection {
  """A list of `NewResolver` objects."""
  nodes: [NewResolver]!

  """
  A list of edges which contains the `NewResolver` and cursor to aid in pagination.
  """
  edges: [NewResolversEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `NewResolver` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: NewResolverAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `NewResolver` for these aggregates."""
    groupBy: [NewResolversGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: NewResolversHavingInput
  ): [NewResolverAggregates!]
}

"""A `NewResolver` edge in the connection."""
type NewResolversEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `NewResolver` at the end of the edge."""
  node: NewResolver
}

"""Grouping methods for `NewResolver` for usage during aggregation."""
enum NewResolversGroupBy {
  NODE
  RESOLVER
}

"""Conditions for `NewResolver` aggregates."""
input NewResolversHavingInput {
  AND: [NewResolversHavingInput!]
  OR: [NewResolversHavingInput!]
}

"""Methods to use when ordering `NewResolver`."""
enum NewResolversOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  NODE_ASC
  NODE_DESC
  RESOLVER_ASC
  RESOLVER_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

type NewSubdomain implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: String!
  to: String
  node: String
  subnode: String
  name: String
}

type NewSubdomainAggregates {
  keys: [String!]
}

"""
A filter to be used against `NewSubdomain` object types. All fields are combined with a logical ‘and.’
"""
input NewSubdomainFilter {
  """Filter by the object’s `id` field."""
  id: StringFilter

  """Filter by the object’s `to` field."""
  to: StringFilter

  """Filter by the object’s `node` field."""
  node: StringFilter

  """Filter by the object’s `subnode` field."""
  subnode: StringFilter

  """Filter by the object’s `name` field."""
  name: StringFilter

  """Checks for all expressions in this list."""
  and: [NewSubdomainFilter!]

  """Checks for any expressions in this list."""
  or: [NewSubdomainFilter!]

  """Negates the expression."""
  not: NewSubdomainFilter
}

"""A connection to a list of `NewSubdomain` values."""
type NewSubdomainsConnection {
  """A list of `NewSubdomain` objects."""
  nodes: [NewSubdomain]!

  """
  A list of edges which contains the `NewSubdomain` and cursor to aid in pagination.
  """
  edges: [NewSubdomainsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `NewSubdomain` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: NewSubdomainAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `NewSubdomain` for these aggregates."""
    groupBy: [NewSubdomainsGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: NewSubdomainsHavingInput
  ): [NewSubdomainAggregates!]
}

"""A `NewSubdomain` edge in the connection."""
type NewSubdomainsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `NewSubdomain` at the end of the edge."""
  node: NewSubdomain
}

"""Grouping methods for `NewSubdomain` for usage during aggregation."""
enum NewSubdomainsGroupBy {
  TO
  NODE
  SUBNODE
  NAME
}

"""Conditions for `NewSubdomain` aggregates."""
input NewSubdomainsHavingInput {
  AND: [NewSubdomainsHavingInput!]
  OR: [NewSubdomainsHavingInput!]
}

"""Methods to use when ordering `NewSubdomain`."""
enum NewSubdomainsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  TO_ASC
  TO_DESC
  NODE_ASC
  NODE_DESC
  SUBNODE_ASC
  SUBNODE_DESC
  NAME_ASC
  NAME_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""An object with a globally unique `ID`."""
interface Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
}

"""Information about pagination in a connection."""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: Cursor

  """When paginating forwards, the cursor to continue."""
  endCursor: Cursor
}

type PnsConfigUpdated implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: String!
  flags: String
}

type PnsConfigUpdatedAggregates {
  keys: [String!]
}

"""
A filter to be used against `PnsConfigUpdated` object types. All fields are combined with a logical ‘and.’
"""
input PnsConfigUpdatedFilter {
  """Filter by the object’s `id` field."""
  id: StringFilter

  """Filter by the object’s `flags` field."""
  flags: StringFilter

  """Checks for all expressions in this list."""
  and: [PnsConfigUpdatedFilter!]

  """Checks for any expressions in this list."""
  or: [PnsConfigUpdatedFilter!]

  """Negates the expression."""
  not: PnsConfigUpdatedFilter
}

"""A connection to a list of `PnsConfigUpdated` values."""
type PnsConfigUpdatedsConnection {
  """A list of `PnsConfigUpdated` objects."""
  nodes: [PnsConfigUpdated]!

  """
  A list of edges which contains the `PnsConfigUpdated` and cursor to aid in pagination.
  """
  edges: [PnsConfigUpdatedsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `PnsConfigUpdated` you could get from the connection.
  """
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: PnsConfigUpdatedAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """
    The method to use when grouping `PnsConfigUpdated` for these aggregates.
    """
    groupBy: [PnsConfigUpdatedsGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: PnsConfigUpdatedsHavingInput
  ): [PnsConfigUpdatedAggregates!]
}

"""A `PnsConfigUpdated` edge in the connection."""
type PnsConfigUpdatedsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `PnsConfigUpdated` at the end of the edge."""
  node: PnsConfigUpdated
}

"""Grouping methods for `PnsConfigUpdated` for usage during aggregation."""
enum PnsConfigUpdatedsGroupBy {
  FLAGS
}

"""Conditions for `PnsConfigUpdated` aggregates."""
input PnsConfigUpdatedsHavingInput {
  AND: [PnsConfigUpdatedsHavingInput!]
  OR: [PnsConfigUpdatedsHavingInput!]
}

"""Methods to use when ordering `PnsConfigUpdated`."""
enum PnsConfigUpdatedsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  FLAGS_ASC
  FLAGS_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

type PriceChanged implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: String!
  basePrices: JSON
  rentPrices: JSON
}

type PriceChangedAggregates {
  keys: [String!]
}

"""
A filter to be used against `PriceChanged` object types. All fields are combined with a logical ‘and.’
"""
input PriceChangedFilter {
  """Filter by the object’s `id` field."""
  id: StringFilter

  """Filter by the object’s `basePrices` field."""
  basePrices: JSONFilter

  """Filter by the object’s `rentPrices` field."""
  rentPrices: JSONFilter

  """Checks for all expressions in this list."""
  and: [PriceChangedFilter!]

  """Checks for any expressions in this list."""
  or: [PriceChangedFilter!]

  """Negates the expression."""
  not: PriceChangedFilter
}

"""A connection to a list of `PriceChanged` values."""
type PriceChangedsConnection {
  """A list of `PriceChanged` objects."""
  nodes: [PriceChanged]!

  """
  A list of edges which contains the `PriceChanged` and cursor to aid in pagination.
  """
  edges: [PriceChangedsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `PriceChanged` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: PriceChangedAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `PriceChanged` for these aggregates."""
    groupBy: [PriceChangedsGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: PriceChangedsHavingInput
  ): [PriceChangedAggregates!]
}

"""A `PriceChanged` edge in the connection."""
type PriceChangedsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `PriceChanged` at the end of the edge."""
  node: PriceChanged
}

"""Grouping methods for `PriceChanged` for usage during aggregation."""
enum PriceChangedsGroupBy {
  BASE_PRICES
  RENT_PRICES
}

"""Conditions for `PriceChanged` aggregates."""
input PriceChangedsHavingInput {
  AND: [PriceChangedsHavingInput!]
  OR: [PriceChangedsHavingInput!]
}

"""Methods to use when ordering `PriceChanged`."""
enum PriceChangedsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  BASE_PRICES_ASC
  BASE_PRICES_DESC
  RENT_PRICES_ASC
  RENT_PRICES_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""The root query type which gives access points into the data universe."""
type Query implements Node {
  """
  Exposes the root query type nested one level down. This is helpful for Relay 1
  which can only query top level fields if they are in a particular form.
  """
  query: Query!

  """
  The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`.
  """
  nodeId: ID!

  """Fetches an object given its globally unique `ID`."""
  node(
    """The globally unique `ID`."""
    nodeId: ID!
  ): Node

  """Reads and enables pagination through a set of `ApprovalForAll`."""
  approvalForAlls(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `ApprovalForAll`."""
    orderBy: [ApprovalForAllsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ApprovalForAllFilter
  ): ApprovalForAllsConnection

  """Reads and enables pagination through a set of `Approval`."""
  approvals(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Approval`."""
    orderBy: [ApprovalsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ApprovalFilter
  ): ApprovalsConnection

  """Reads and enables pagination through a set of `CapacityChanged`."""
  capacityChangeds(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `CapacityChanged`."""
    orderBy: [CapacityChangedsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CapacityChangedFilter
  ): CapacityChangedsConnection

  """
  Reads and enables pagination through a set of `ControllerConfigUpdated`.
  """
  controllerConfigUpdateds(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `ControllerConfigUpdated`."""
    orderBy: [ControllerConfigUpdatedsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ControllerConfigUpdatedFilter
  ): ControllerConfigUpdatedsConnection

  """Reads and enables pagination through a set of `ManagerChanged`."""
  managerChangeds(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `ManagerChanged`."""
    orderBy: [ManagerChangedsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ManagerChangedFilter
  ): ManagerChangedsConnection

  """Reads and enables pagination through a set of `MetadataUpdated`."""
  metadataUpdateds(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `MetadataUpdated`."""
    orderBy: [MetadataUpdatedsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: MetadataUpdatedFilter
  ): MetadataUpdatedsConnection

  """Reads and enables pagination through a set of `NameRedeem`."""
  nameRedeems(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `NameRedeem`."""
    orderBy: [NameRedeemsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: NameRedeemFilter
  ): NameRedeemsConnection

  """Reads and enables pagination through a set of `NameRegisterByManager`."""
  nameRegisterByManagers(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `NameRegisterByManager`."""
    orderBy: [NameRegisterByManagersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: NameRegisterByManagerFilter
  ): NameRegisterByManagersConnection

  """
  Reads and enables pagination through a set of `NameRegisterWithConfig`.
  """
  nameRegisterWithConfigs(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `NameRegisterWithConfig`."""
    orderBy: [NameRegisterWithConfigsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: NameRegisterWithConfigFilter
  ): NameRegisterWithConfigsConnection

  """Reads and enables pagination through a set of `NameRegistered`."""
  nameRegistereds(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `NameRegistered`."""
    orderBy: [NameRegisteredsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: NameRegisteredFilter
  ): NameRegisteredsConnection

  """Reads and enables pagination through a set of `NameRegister`."""
  nameRegisters(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `NameRegister`."""
    orderBy: [NameRegistersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: NameRegisterFilter
  ): NameRegistersConnection

  """Reads and enables pagination through a set of `NameRenewed`."""
  nameReneweds(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `NameRenewed`."""
    orderBy: [NameRenewedsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: NameRenewedFilter
  ): NameRenewedsConnection

  """Reads and enables pagination through a set of `NewKey`."""
  newKeys(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `NewKey`."""
    orderBy: [NewKeysOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: NewKeyFilter
  ): NewKeysConnection

  """Reads and enables pagination through a set of `NewResolver`."""
  newResolvers(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `NewResolver`."""
    orderBy: [NewResolversOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: NewResolverFilter
  ): NewResolversConnection

  """Reads and enables pagination through a set of `NewSubdomain`."""
  newSubdomains(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `NewSubdomain`."""
    orderBy: [NewSubdomainsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: NewSubdomainFilter
  ): NewSubdomainsConnection

  """Reads and enables pagination through a set of `PnsConfigUpdated`."""
  pnsConfigUpdateds(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `PnsConfigUpdated`."""
    orderBy: [PnsConfigUpdatedsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: PnsConfigUpdatedFilter
  ): PnsConfigUpdatedsConnection

  """Reads and enables pagination through a set of `PriceChanged`."""
  priceChangeds(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `PriceChanged`."""
    orderBy: [PriceChangedsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: PriceChangedFilter
  ): PriceChangedsConnection

  """Reads and enables pagination through a set of `RenewByManager`."""
  renewByManagers(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `RenewByManager`."""
    orderBy: [RenewByManagersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: RenewByManagerFilter
  ): RenewByManagersConnection

  """Reads and enables pagination through a set of `Renew`."""
  renews(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Renew`."""
    orderBy: [RenewsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: RenewFilter
  ): RenewsConnection

  """Reads and enables pagination through a set of `ResetRecord`."""
  resetRecords(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `ResetRecord`."""
    orderBy: [ResetRecordsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ResetRecordFilter
  ): ResetRecordsConnection

  """
  Reads and enables pagination through a set of `RootOwnershipTransferred`.
  """
  rootOwnershipTransferreds(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `RootOwnershipTransferred`."""
    orderBy: [RootOwnershipTransferredsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: RootOwnershipTransferredFilter
  ): RootOwnershipTransferredsConnection

  """Reads and enables pagination through a set of `SetName`."""
  setNames(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `SetName`."""
    orderBy: [SetNamesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: SetNameFilter
  ): SetNamesConnection

  """Reads and enables pagination through a set of `SetNftName`."""
  setNftNames(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `SetNftName`."""
    orderBy: [SetNftNamesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: SetNftNameFilter
  ): SetNftNamesConnection

  """Reads and enables pagination through a set of `Set`."""
  sets(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Set`."""
    orderBy: [SetsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: SetFilter
  ): SetsConnection

  """Reads and enables pagination through a set of `Subdomain`."""
  subdomains(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Subdomain`."""
    orderBy: [SubdomainsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: SubdomainFilter
  ): SubdomainsConnection

  """Reads and enables pagination through a set of `Transfer`."""
  transfers(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Transfer`."""
    orderBy: [TransfersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TransferFilter
  ): TransfersConnection
  approvalForAll(id: String!): ApprovalForAll
  approval(id: String!): Approval
  capacityChanged(id: String!): CapacityChanged
  controllerConfigUpdated(id: String!): ControllerConfigUpdated
  managerChanged(id: String!): ManagerChanged
  metadataUpdated(id: String!): MetadataUpdated
  nameRedeem(id: String!): NameRedeem
  nameRegisterByManager(id: String!): NameRegisterByManager
  nameRegisterWithConfig(id: String!): NameRegisterWithConfig
  nameRegistered(id: String!): NameRegistered
  nameRegister(id: String!): NameRegister
  nameRenewed(id: String!): NameRenewed
  newKey(id: String!): NewKey
  newResolver(id: String!): NewResolver
  newSubdomain(id: String!): NewSubdomain
  pnsConfigUpdated(id: String!): PnsConfigUpdated
  priceChanged(id: String!): PriceChanged
  renewByManager(id: String!): RenewByManager
  renew(id: String!): Renew
  resetRecord(id: String!): ResetRecord
  rootOwnershipTransferred(id: String!): RootOwnershipTransferred
  setName(id: String!): SetName
  setNftName(id: String!): SetNftName
  set(id: String!): Set
  subdomain(id: String!): Subdomain
  transfer(id: String!): Transfer

  """Reads a single `ApprovalForAll` using its globally unique `ID`."""
  approvalForAllByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `ApprovalForAll`.
    """
    nodeId: ID!
  ): ApprovalForAll

  """Reads a single `Approval` using its globally unique `ID`."""
  approvalByNodeId(
    """The globally unique `ID` to be used in selecting a single `Approval`."""
    nodeId: ID!
  ): Approval

  """Reads a single `CapacityChanged` using its globally unique `ID`."""
  capacityChangedByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `CapacityChanged`.
    """
    nodeId: ID!
  ): CapacityChanged

  """
  Reads a single `ControllerConfigUpdated` using its globally unique `ID`.
  """
  controllerConfigUpdatedByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `ControllerConfigUpdated`.
    """
    nodeId: ID!
  ): ControllerConfigUpdated

  """Reads a single `ManagerChanged` using its globally unique `ID`."""
  managerChangedByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `ManagerChanged`.
    """
    nodeId: ID!
  ): ManagerChanged

  """Reads a single `MetadataUpdated` using its globally unique `ID`."""
  metadataUpdatedByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `MetadataUpdated`.
    """
    nodeId: ID!
  ): MetadataUpdated

  """Reads a single `NameRedeem` using its globally unique `ID`."""
  nameRedeemByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `NameRedeem`.
    """
    nodeId: ID!
  ): NameRedeem

  """Reads a single `NameRegisterByManager` using its globally unique `ID`."""
  nameRegisterByManagerByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `NameRegisterByManager`.
    """
    nodeId: ID!
  ): NameRegisterByManager

  """
  Reads a single `NameRegisterWithConfig` using its globally unique `ID`.
  """
  nameRegisterWithConfigByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `NameRegisterWithConfig`.
    """
    nodeId: ID!
  ): NameRegisterWithConfig

  """Reads a single `NameRegistered` using its globally unique `ID`."""
  nameRegisteredByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `NameRegistered`.
    """
    nodeId: ID!
  ): NameRegistered

  """Reads a single `NameRegister` using its globally unique `ID`."""
  nameRegisterByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `NameRegister`.
    """
    nodeId: ID!
  ): NameRegister

  """Reads a single `NameRenewed` using its globally unique `ID`."""
  nameRenewedByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `NameRenewed`.
    """
    nodeId: ID!
  ): NameRenewed

  """Reads a single `NewKey` using its globally unique `ID`."""
  newKeyByNodeId(
    """The globally unique `ID` to be used in selecting a single `NewKey`."""
    nodeId: ID!
  ): NewKey

  """Reads a single `NewResolver` using its globally unique `ID`."""
  newResolverByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `NewResolver`.
    """
    nodeId: ID!
  ): NewResolver

  """Reads a single `NewSubdomain` using its globally unique `ID`."""
  newSubdomainByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `NewSubdomain`.
    """
    nodeId: ID!
  ): NewSubdomain

  """Reads a single `PnsConfigUpdated` using its globally unique `ID`."""
  pnsConfigUpdatedByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `PnsConfigUpdated`.
    """
    nodeId: ID!
  ): PnsConfigUpdated

  """Reads a single `PriceChanged` using its globally unique `ID`."""
  priceChangedByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `PriceChanged`.
    """
    nodeId: ID!
  ): PriceChanged

  """Reads a single `RenewByManager` using its globally unique `ID`."""
  renewByManagerByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `RenewByManager`.
    """
    nodeId: ID!
  ): RenewByManager

  """Reads a single `Renew` using its globally unique `ID`."""
  renewByNodeId(
    """The globally unique `ID` to be used in selecting a single `Renew`."""
    nodeId: ID!
  ): Renew

  """Reads a single `ResetRecord` using its globally unique `ID`."""
  resetRecordByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `ResetRecord`.
    """
    nodeId: ID!
  ): ResetRecord

  """
  Reads a single `RootOwnershipTransferred` using its globally unique `ID`.
  """
  rootOwnershipTransferredByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `RootOwnershipTransferred`.
    """
    nodeId: ID!
  ): RootOwnershipTransferred

  """Reads a single `SetName` using its globally unique `ID`."""
  setNameByNodeId(
    """The globally unique `ID` to be used in selecting a single `SetName`."""
    nodeId: ID!
  ): SetName

  """Reads a single `SetNftName` using its globally unique `ID`."""
  setNftNameByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `SetNftName`.
    """
    nodeId: ID!
  ): SetNftName

  """Reads a single `Set` using its globally unique `ID`."""
  setByNodeId(
    """The globally unique `ID` to be used in selecting a single `Set`."""
    nodeId: ID!
  ): Set

  """Reads a single `Subdomain` using its globally unique `ID`."""
  subdomainByNodeId(
    """The globally unique `ID` to be used in selecting a single `Subdomain`."""
    nodeId: ID!
  ): Subdomain

  """Reads a single `Transfer` using its globally unique `ID`."""
  transferByNodeId(
    """The globally unique `ID` to be used in selecting a single `Transfer`."""
    nodeId: ID!
  ): Transfer
  _metadata: _Metadata
}

type Renew implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: String!
  name: String
  duration: String
  success: Boolean
  timestamp: Int
  from: String
}

type RenewAggregates {
  keys: [String!]
}

type RenewByManager implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: String!
  name: String
  duration: String
  success: Boolean
  timestamp: Int
  from: String
}

type RenewByManagerAggregates {
  keys: [String!]
}

"""
A filter to be used against `RenewByManager` object types. All fields are combined with a logical ‘and.’
"""
input RenewByManagerFilter {
  """Filter by the object’s `id` field."""
  id: StringFilter

  """Filter by the object’s `name` field."""
  name: StringFilter

  """Filter by the object’s `duration` field."""
  duration: StringFilter

  """Filter by the object’s `success` field."""
  success: BooleanFilter

  """Filter by the object’s `timestamp` field."""
  timestamp: IntFilter

  """Filter by the object’s `from` field."""
  from: StringFilter

  """Checks for all expressions in this list."""
  and: [RenewByManagerFilter!]

  """Checks for any expressions in this list."""
  or: [RenewByManagerFilter!]

  """Negates the expression."""
  not: RenewByManagerFilter
}

"""A connection to a list of `RenewByManager` values."""
type RenewByManagersConnection {
  """A list of `RenewByManager` objects."""
  nodes: [RenewByManager]!

  """
  A list of edges which contains the `RenewByManager` and cursor to aid in pagination.
  """
  edges: [RenewByManagersEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `RenewByManager` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: RenewByManagerAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `RenewByManager` for these aggregates."""
    groupBy: [RenewByManagersGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: RenewByManagersHavingInput
  ): [RenewByManagerAggregates!]
}

"""A `RenewByManager` edge in the connection."""
type RenewByManagersEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `RenewByManager` at the end of the edge."""
  node: RenewByManager
}

"""Grouping methods for `RenewByManager` for usage during aggregation."""
enum RenewByManagersGroupBy {
  NAME
  DURATION
  SUCCESS
  TIMESTAMP
  FROM
}

"""Conditions for `RenewByManager` aggregates."""
input RenewByManagersHavingInput {
  AND: [RenewByManagersHavingInput!]
  OR: [RenewByManagersHavingInput!]
}

"""Methods to use when ordering `RenewByManager`."""
enum RenewByManagersOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  DURATION_ASC
  DURATION_DESC
  SUCCESS_ASC
  SUCCESS_DESC
  TIMESTAMP_ASC
  TIMESTAMP_DESC
  FROM_ASC
  FROM_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A filter to be used against `Renew` object types. All fields are combined with a logical ‘and.’
"""
input RenewFilter {
  """Filter by the object’s `id` field."""
  id: StringFilter

  """Filter by the object’s `name` field."""
  name: StringFilter

  """Filter by the object’s `duration` field."""
  duration: StringFilter

  """Filter by the object’s `success` field."""
  success: BooleanFilter

  """Filter by the object’s `timestamp` field."""
  timestamp: IntFilter

  """Filter by the object’s `from` field."""
  from: StringFilter

  """Checks for all expressions in this list."""
  and: [RenewFilter!]

  """Checks for any expressions in this list."""
  or: [RenewFilter!]

  """Negates the expression."""
  not: RenewFilter
}

"""A connection to a list of `Renew` values."""
type RenewsConnection {
  """A list of `Renew` objects."""
  nodes: [Renew]!

  """
  A list of edges which contains the `Renew` and cursor to aid in pagination.
  """
  edges: [RenewsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Renew` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: RenewAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `Renew` for these aggregates."""
    groupBy: [RenewsGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: RenewsHavingInput
  ): [RenewAggregates!]
}

"""A `Renew` edge in the connection."""
type RenewsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Renew` at the end of the edge."""
  node: Renew
}

"""Grouping methods for `Renew` for usage during aggregation."""
enum RenewsGroupBy {
  NAME
  DURATION
  SUCCESS
  TIMESTAMP
  FROM
}

"""Conditions for `Renew` aggregates."""
input RenewsHavingInput {
  AND: [RenewsHavingInput!]
  OR: [RenewsHavingInput!]
}

"""Methods to use when ordering `Renew`."""
enum RenewsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  DURATION_ASC
  DURATION_DESC
  SUCCESS_ASC
  SUCCESS_DESC
  TIMESTAMP_ASC
  TIMESTAMP_DESC
  FROM_ASC
  FROM_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

type ResetRecord implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: String!
  node: String
}

type ResetRecordAggregates {
  keys: [String!]
}

"""
A filter to be used against `ResetRecord` object types. All fields are combined with a logical ‘and.’
"""
input ResetRecordFilter {
  """Filter by the object’s `id` field."""
  id: StringFilter

  """Filter by the object’s `node` field."""
  node: StringFilter

  """Checks for all expressions in this list."""
  and: [ResetRecordFilter!]

  """Checks for any expressions in this list."""
  or: [ResetRecordFilter!]

  """Negates the expression."""
  not: ResetRecordFilter
}

"""A connection to a list of `ResetRecord` values."""
type ResetRecordsConnection {
  """A list of `ResetRecord` objects."""
  nodes: [ResetRecord]!

  """
  A list of edges which contains the `ResetRecord` and cursor to aid in pagination.
  """
  edges: [ResetRecordsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `ResetRecord` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: ResetRecordAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `ResetRecord` for these aggregates."""
    groupBy: [ResetRecordsGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: ResetRecordsHavingInput
  ): [ResetRecordAggregates!]
}

"""A `ResetRecord` edge in the connection."""
type ResetRecordsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `ResetRecord` at the end of the edge."""
  node: ResetRecord
}

"""Grouping methods for `ResetRecord` for usage during aggregation."""
enum ResetRecordsGroupBy {
  NODE
}

"""Conditions for `ResetRecord` aggregates."""
input ResetRecordsHavingInput {
  AND: [ResetRecordsHavingInput!]
  OR: [ResetRecordsHavingInput!]
}

"""Methods to use when ordering `ResetRecord`."""
enum ResetRecordsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  NODE_ASC
  NODE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

type RootOwnershipTransferred implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: String!
  oldRoot: String
  newRoot: String
}

type RootOwnershipTransferredAggregates {
  keys: [String!]
}

"""
A filter to be used against `RootOwnershipTransferred` object types. All fields are combined with a logical ‘and.’
"""
input RootOwnershipTransferredFilter {
  """Filter by the object’s `id` field."""
  id: StringFilter

  """Filter by the object’s `oldRoot` field."""
  oldRoot: StringFilter

  """Filter by the object’s `newRoot` field."""
  newRoot: StringFilter

  """Checks for all expressions in this list."""
  and: [RootOwnershipTransferredFilter!]

  """Checks for any expressions in this list."""
  or: [RootOwnershipTransferredFilter!]

  """Negates the expression."""
  not: RootOwnershipTransferredFilter
}

"""A connection to a list of `RootOwnershipTransferred` values."""
type RootOwnershipTransferredsConnection {
  """A list of `RootOwnershipTransferred` objects."""
  nodes: [RootOwnershipTransferred]!

  """
  A list of edges which contains the `RootOwnershipTransferred` and cursor to aid in pagination.
  """
  edges: [RootOwnershipTransferredsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `RootOwnershipTransferred` you could get from the connection.
  """
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: RootOwnershipTransferredAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """
    The method to use when grouping `RootOwnershipTransferred` for these aggregates.
    """
    groupBy: [RootOwnershipTransferredsGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: RootOwnershipTransferredsHavingInput
  ): [RootOwnershipTransferredAggregates!]
}

"""A `RootOwnershipTransferred` edge in the connection."""
type RootOwnershipTransferredsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `RootOwnershipTransferred` at the end of the edge."""
  node: RootOwnershipTransferred
}

"""
Grouping methods for `RootOwnershipTransferred` for usage during aggregation.
"""
enum RootOwnershipTransferredsGroupBy {
  OLD_ROOT
  NEW_ROOT
}

"""Conditions for `RootOwnershipTransferred` aggregates."""
input RootOwnershipTransferredsHavingInput {
  AND: [RootOwnershipTransferredsHavingInput!]
  OR: [RootOwnershipTransferredsHavingInput!]
}

"""Methods to use when ordering `RootOwnershipTransferred`."""
enum RootOwnershipTransferredsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  OLD_ROOT_ASC
  OLD_ROOT_DESC
  NEW_ROOT_ASC
  NEW_ROOT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

type Set implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: String!
  node: String
  keyHash: String
  value: String
}

type SetAggregates {
  keys: [String!]
}

"""
A filter to be used against `Set` object types. All fields are combined with a logical ‘and.’
"""
input SetFilter {
  """Filter by the object’s `id` field."""
  id: StringFilter

  """Filter by the object’s `node` field."""
  node: StringFilter

  """Filter by the object’s `keyHash` field."""
  keyHash: StringFilter

  """Filter by the object’s `value` field."""
  value: StringFilter

  """Checks for all expressions in this list."""
  and: [SetFilter!]

  """Checks for any expressions in this list."""
  or: [SetFilter!]

  """Negates the expression."""
  not: SetFilter
}

type SetName implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: String!
  addr: String
  node: String
}

type SetNameAggregates {
  keys: [String!]
}

"""
A filter to be used against `SetName` object types. All fields are combined with a logical ‘and.’
"""
input SetNameFilter {
  """Filter by the object’s `id` field."""
  id: StringFilter

  """Filter by the object’s `addr` field."""
  addr: StringFilter

  """Filter by the object’s `node` field."""
  node: StringFilter

  """Checks for all expressions in this list."""
  and: [SetNameFilter!]

  """Checks for any expressions in this list."""
  or: [SetNameFilter!]

  """Negates the expression."""
  not: SetNameFilter
}

"""A connection to a list of `SetName` values."""
type SetNamesConnection {
  """A list of `SetName` objects."""
  nodes: [SetName]!

  """
  A list of edges which contains the `SetName` and cursor to aid in pagination.
  """
  edges: [SetNamesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `SetName` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: SetNameAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `SetName` for these aggregates."""
    groupBy: [SetNamesGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: SetNamesHavingInput
  ): [SetNameAggregates!]
}

"""A `SetName` edge in the connection."""
type SetNamesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `SetName` at the end of the edge."""
  node: SetName
}

"""Grouping methods for `SetName` for usage during aggregation."""
enum SetNamesGroupBy {
  ADDR
  NODE
}

"""Conditions for `SetName` aggregates."""
input SetNamesHavingInput {
  AND: [SetNamesHavingInput!]
  OR: [SetNamesHavingInput!]
}

"""Methods to use when ordering `SetName`."""
enum SetNamesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  ADDR_ASC
  ADDR_DESC
  NODE_ASC
  NODE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

type SetNftName implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: String!
  nftAddr: String
  nftNode: String
  node: String
}

type SetNftNameAggregates {
  keys: [String!]
}

"""
A filter to be used against `SetNftName` object types. All fields are combined with a logical ‘and.’
"""
input SetNftNameFilter {
  """Filter by the object’s `id` field."""
  id: StringFilter

  """Filter by the object’s `nftAddr` field."""
  nftAddr: StringFilter

  """Filter by the object’s `nftNode` field."""
  nftNode: StringFilter

  """Filter by the object’s `node` field."""
  node: StringFilter

  """Checks for all expressions in this list."""
  and: [SetNftNameFilter!]

  """Checks for any expressions in this list."""
  or: [SetNftNameFilter!]

  """Negates the expression."""
  not: SetNftNameFilter
}

"""A connection to a list of `SetNftName` values."""
type SetNftNamesConnection {
  """A list of `SetNftName` objects."""
  nodes: [SetNftName]!

  """
  A list of edges which contains the `SetNftName` and cursor to aid in pagination.
  """
  edges: [SetNftNamesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `SetNftName` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: SetNftNameAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `SetNftName` for these aggregates."""
    groupBy: [SetNftNamesGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: SetNftNamesHavingInput
  ): [SetNftNameAggregates!]
}

"""A `SetNftName` edge in the connection."""
type SetNftNamesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `SetNftName` at the end of the edge."""
  node: SetNftName
}

"""Grouping methods for `SetNftName` for usage during aggregation."""
enum SetNftNamesGroupBy {
  NFT_ADDR
  NFT_NODE
  NODE
}

"""Conditions for `SetNftName` aggregates."""
input SetNftNamesHavingInput {
  AND: [SetNftNamesHavingInput!]
  OR: [SetNftNamesHavingInput!]
}

"""Methods to use when ordering `SetNftName`."""
enum SetNftNamesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  NFT_ADDR_ASC
  NFT_ADDR_DESC
  NFT_NODE_ASC
  NFT_NODE_DESC
  NODE_ASC
  NODE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""A connection to a list of `Set` values."""
type SetsConnection {
  """A list of `Set` objects."""
  nodes: [Set]!

  """
  A list of edges which contains the `Set` and cursor to aid in pagination.
  """
  edges: [SetsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Set` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: SetAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `Set` for these aggregates."""
    groupBy: [SetsGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: SetsHavingInput
  ): [SetAggregates!]
}

"""A `Set` edge in the connection."""
type SetsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Set` at the end of the edge."""
  node: Set
}

"""Grouping methods for `Set` for usage during aggregation."""
enum SetsGroupBy {
  NODE
  KEY_HASH
  VALUE
}

"""Conditions for `Set` aggregates."""
input SetsHavingInput {
  AND: [SetsHavingInput!]
  OR: [SetsHavingInput!]
}

"""Methods to use when ordering `Set`."""
enum SetsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  NODE_ASC
  NODE_DESC
  KEY_HASH_ASC
  KEY_HASH_DESC
  VALUE_ASC
  VALUE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A filter to be used against String fields. All fields are combined with a logical ‘and.’
"""
input StringFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: String

  """Not equal to the specified value."""
  notEqualTo: String

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: String

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: String

  """Included in the specified list."""
  in: [String!]

  """Not included in the specified list."""
  notIn: [String!]

  """Less than the specified value."""
  lessThan: String

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: String

  """Greater than the specified value."""
  greaterThan: String

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: String

  """Contains the specified string (case-sensitive)."""
  includes: String

  """Does not contain the specified string (case-sensitive)."""
  notIncludes: String

  """Contains the specified string (case-insensitive)."""
  includesInsensitive: String

  """Does not contain the specified string (case-insensitive)."""
  notIncludesInsensitive: String

  """Starts with the specified string (case-sensitive)."""
  startsWith: String

  """Does not start with the specified string (case-sensitive)."""
  notStartsWith: String

  """Starts with the specified string (case-insensitive)."""
  startsWithInsensitive: String

  """Does not start with the specified string (case-insensitive)."""
  notStartsWithInsensitive: String

  """Ends with the specified string (case-sensitive)."""
  endsWith: String

  """Does not end with the specified string (case-sensitive)."""
  notEndsWith: String

  """Ends with the specified string (case-insensitive)."""
  endsWithInsensitive: String

  """Does not end with the specified string (case-insensitive)."""
  notEndsWithInsensitive: String

  """
  Matches the specified pattern (case-sensitive). An underscore (_) matches any
  single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  like: String

  """
  Does not match the specified pattern (case-sensitive). An underscore (_)
  matches any single character; a percent sign (%) matches any sequence of zero
  or more characters.
  """
  notLike: String

  """
  Matches the specified pattern (case-insensitive). An underscore (_) matches
  any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  likeInsensitive: String

  """
  Does not match the specified pattern (case-insensitive). An underscore (_)
  matches any single character; a percent sign (%) matches any sequence of zero
  or more characters.
  """
  notLikeInsensitive: String

  """Equal to the specified value (case-insensitive)."""
  equalToInsensitive: String

  """Not equal to the specified value (case-insensitive)."""
  notEqualToInsensitive: String

  """
  Not equal to the specified value, treating null like an ordinary value (case-insensitive).
  """
  distinctFromInsensitive: String

  """
  Equal to the specified value, treating null like an ordinary value (case-insensitive).
  """
  notDistinctFromInsensitive: String

  """Included in the specified list (case-insensitive)."""
  inInsensitive: [String!]

  """Not included in the specified list (case-insensitive)."""
  notInInsensitive: [String!]

  """Less than the specified value (case-insensitive)."""
  lessThanInsensitive: String

  """Less than or equal to the specified value (case-insensitive)."""
  lessThanOrEqualToInsensitive: String

  """Greater than the specified value (case-insensitive)."""
  greaterThanInsensitive: String

  """Greater than or equal to the specified value (case-insensitive)."""
  greaterThanOrEqualToInsensitive: String
}

type Subdomain implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: String!
  name: String
  parent: String
  owner: String
}

type SubdomainAggregates {
  keys: [String!]
}

"""
A filter to be used against `Subdomain` object types. All fields are combined with a logical ‘and.’
"""
input SubdomainFilter {
  """Filter by the object’s `id` field."""
  id: StringFilter

  """Filter by the object’s `name` field."""
  name: StringFilter

  """Filter by the object’s `parent` field."""
  parent: StringFilter

  """Filter by the object’s `owner` field."""
  owner: StringFilter

  """Checks for all expressions in this list."""
  and: [SubdomainFilter!]

  """Checks for any expressions in this list."""
  or: [SubdomainFilter!]

  """Negates the expression."""
  not: SubdomainFilter
}

"""A connection to a list of `Subdomain` values."""
type SubdomainsConnection {
  """A list of `Subdomain` objects."""
  nodes: [Subdomain]!

  """
  A list of edges which contains the `Subdomain` and cursor to aid in pagination.
  """
  edges: [SubdomainsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Subdomain` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: SubdomainAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `Subdomain` for these aggregates."""
    groupBy: [SubdomainsGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: SubdomainsHavingInput
  ): [SubdomainAggregates!]
}

"""A `Subdomain` edge in the connection."""
type SubdomainsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Subdomain` at the end of the edge."""
  node: Subdomain
}

"""Grouping methods for `Subdomain` for usage during aggregation."""
enum SubdomainsGroupBy {
  NAME
  PARENT
  OWNER
}

"""Conditions for `Subdomain` aggregates."""
input SubdomainsHavingInput {
  AND: [SubdomainsHavingInput!]
  OR: [SubdomainsHavingInput!]
}

"""Methods to use when ordering `Subdomain`."""
enum SubdomainsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  PARENT_ASC
  PARENT_DESC
  OWNER_ASC
  OWNER_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

type TableEstimate {
  table: String
  estimate: Int
}

type Transfer implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: String!
  from: String
  to: String
  node: String
}

type TransferAggregates {
  keys: [String!]
}

"""
A filter to be used against `Transfer` object types. All fields are combined with a logical ‘and.’
"""
input TransferFilter {
  """Filter by the object’s `id` field."""
  id: StringFilter

  """Filter by the object’s `from` field."""
  from: StringFilter

  """Filter by the object’s `to` field."""
  to: StringFilter

  """Filter by the object’s `node` field."""
  node: StringFilter

  """Checks for all expressions in this list."""
  and: [TransferFilter!]

  """Checks for any expressions in this list."""
  or: [TransferFilter!]

  """Negates the expression."""
  not: TransferFilter
}

"""A connection to a list of `Transfer` values."""
type TransfersConnection {
  """A list of `Transfer` objects."""
  nodes: [Transfer]!

  """
  A list of edges which contains the `Transfer` and cursor to aid in pagination.
  """
  edges: [TransfersEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Transfer` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: TransferAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `Transfer` for these aggregates."""
    groupBy: [TransfersGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: TransfersHavingInput
  ): [TransferAggregates!]
}

"""A `Transfer` edge in the connection."""
type TransfersEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Transfer` at the end of the edge."""
  node: Transfer
}

"""Grouping methods for `Transfer` for usage during aggregation."""
enum TransfersGroupBy {
  FROM
  TO
  NODE
}

"""Conditions for `Transfer` aggregates."""
input TransfersHavingInput {
  AND: [TransfersHavingInput!]
  OR: [TransfersHavingInput!]
}

"""Methods to use when ordering `Transfer`."""
enum TransfersOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  FROM_ASC
  FROM_DESC
  TO_ASC
  TO_DESC
  NODE_ASC
  NODE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

